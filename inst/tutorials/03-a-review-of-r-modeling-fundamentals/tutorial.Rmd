---
title: A Review of R Modeling Fundamentals
author: David Kane and Aryan Kancherla
tutorial:
  id: a-review-of-r-modeling-fundamentals
output:
  learnr::tutorial:
    progressive: yes
    allow_skip: yes
runtime: shiny_prerendered
description: 'Tutorial for Chapter 3: A Review of R Modeling Fundamentals'
---

```{r setup, include = FALSE}
library(learnr)
library(tutorial.helpers)
library(tidyverse)
library(modeldata)
library(lattice)

knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 60, 
        tutorial.storage = "local")

crickets_plot <- crickets |>
  ggplot(aes(x = temp, y = rate, color = species, pch = species, lty = species)) +
    geom_point(size = 2) + 
      geom_smooth(method = lm, se = FALSE, alpha = 0.5) + 
         scale_color_brewer(palette = "Paired") +
            labs(
              x = "Temperature (C)", 
              y = "Chirp Rate (per minute)"
            )

interaction_fit <- lm(formula = rate ~ (temp + species)^2, data = crickets)
main_effect_fit <-  lm(rate ~ temp + species, data = crickets) 
new_values <- data.frame(species = "O. exclamationis", temp = 15:20)

```

```{r copy-code-chunk, child = system.file("child_documents/copy_button.Rmd", package = "tutorial.helpers")}
```

```{r info-section, child = system.file("child_documents/info_section.Rmd", package = "tutorial.helpers")}
```

## Introduction
### 

This tutorial covers [Chapter 3: A Review of R Modeling Fundamentals](https://www.tmwr.org/base-r.html) from [*Tidy Modeling with R*](https://www.tmwr.org/) by Max Kuhn and Julia Silge. This chapter will cover the creation of fitted linear & predictive models, with the use of the `lm()` and `predict()` functions, as well as the [*Tidyverse*](https://www.tidyverse.org) and [*Modeldata*](https://cran.r-project.org/web/packages/modeldata/index.html) packages.

## Modeling in Base R
### 

Let's use experimental data on the relationship between the ambient temperature and the rate of cricket chirps per minute. Data were collected for two species: `O. exclamationis` and `O. niveus`. The data is contained in a data frame called crickets, with a total of 31 data points.

### Exercise 1

Load the **tidyverse** library using `library()`.

```{r modeling-in-base-r-1, exercise = TRUE}

```

```{r modeling-in-base-r-1-hint-1, eval = FALSE}
library(...)
```

```{r include = FALSE}
library(tidyverse)
```

### 

The core **tidyverse** library includes the following packages: **ggplot2**, **dplyr**, **tidyr**, **readr**, **purrr**, **tibble**, **stringr**, and **forcats**.

### Exercise 2

Now, load the **modeldata** package.

```{r modeling-in-base-r-2, exercise = TRUE}

```

```{r modeling-in-base-r-2-hint-1, eval = FALSE}
library(...)
```

```{r include = FALSE}
library(modeldata)
```

### 

The S language, on which R is based, introduced standard infrastructure components familiar to R users today, such as symbolic model formulae, model matrices, and data frames, as well as standard object-oriented programming methods for data analysis. 

### Exercise 3

We will be using the `crickets` tibble from the **modeldata** package. Type in `crickets` and press "Run Code".

```{r modeling-in-base-r-3, exercise = TRUE}

```

```{r modeling-in-base-r-3-hint-1, eval = FALSE}
...
```

```{r include = FALSE}
crickets
```

### 

Another way to load **modeldata** and `crickets` would be to use the `data()` function:
```         
data(crickets, package = "modeldata")
```

### Exercise 4

The `names()` function can be used to get the column names of `crickets`. In the code chunk below, type in `names()`, passing in `crickets`.

```{r modeling-in-base-r-4, exercise = TRUE}

```

```{r modeling-in-base-r-4-hint-1, eval = FALSE}
...(...)
```

```{r include = FALSE}
names(crickets)
```

### 

As you can see, the column names of the `crickets` dataframe are `species, temp` and `rate`. The `rate` column refers to the crickets chirping rate, the `temp` column refers to the temperature (in Celsius) the crickets were in, and the `species` column refers to the species of the cricket.

### Exercise 5

<!-- DK: Insert code here creating cricket plot, and assigning it to an object. Then, print the object. Then print the object again at the end. Done -->

Using the data from the `crickets` tibble, lets make this plot:

```{r}
crickets_plot
```

In the code chunk below, type in `crickets` and pipe it to `ggplot()`.

```{r modeling-in-base-r-5, exercise = TRUE}

```

```{r modeling-in-base-r-5-hint-1, eval = FALSE}
crickets |>
  ...()
```

```{r include = FALSE}
crickets |>
    ggplot()
```

### 

`ggplot()` comes from the **ggplot2** package, which is included in the **tidyverse** package. `ggplot()` is used to create graphs from data.

### Exercise 6

Copy the previous code. Inside `ggplot()`, type in `aes()`. Inside `aes()`, set `x` to `temp` and y to `rate`.

```{r modeling-in-base-r-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r modeling-in-base-r-6-hint-1, eval = FALSE}
crickets |>
    ggplot(...(
      x = ..., 
      y = ...)
      )
      
```

```{r include = FALSE}
crickets |>
    ggplot(aes(
      x = temp, 
      y = rate)
      )
```

### 

The `aes()` is used to specify the desired *aesthetics* of a graph (hence the name "aes"). As you can see, with the use of the `aes()` function, the graph now has an x-axis and y-axis label.

### Exercise 7

Copy the previous code. Inside `aes()`, set arguments `color`, `pch`, and `lty` to `species`. 

```{r modeling-in-base-r-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r modeling-in-base-r-7-hint-1, eval = FALSE}
crickets |>
    ggplot(aes(x = temp, 
               y = rate, 
               ... = species, 
               pch = ..., 
               ... = species)
           )
```

```{r include = FALSE}
crickets |>
    ggplot(aes(x = temp, 
               y = rate, 
               color = species, 
               pch = species, 
               lty = species))
```

### 

By setting `color`, `pch`, and `lty` to `species`, the graph will plot points for each data point and set the color of them by species.

### Exercise 8

Copy the previous code. Add `geom_point()` and pass in `size = 2`.

```{r modeling-in-base-r-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r modeling-in-base-r-8-hint-1, eval = FALSE}
... + 
  geom_point(... = ...)
```

```{r include = FALSE}
crickets |>
  ggplot(aes(x = temp, 
             y = rate, 
             color = species, 
             pch = species, 
             lty = species)) +
    geom_point(size = 2)
```

### 

The `geom_point()` function adds data points (each as an individual dot) to the graph. By setting the `size` parameter to `2`, each point on the graph will have the size of `2`, instead of the default size. 

### Exercise 9

Copy the previous code. Now, add `geom_smooth()` to your code and set `method` to `"lm"`.

```{r modeling-in-base-r-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r modeling-in-base-r-9-hint-1, eval = FALSE}
... + 
  geom_smooth(... = "...")
```

```{r include = FALSE}
crickets |>
  ggplot(aes(x = temp, 
             y = rate, 
             color = species, 
             pch = species, 
             lty = species)) +
    geom_point(size = 2) + 
      geom_smooth(method = "lm")
```

### 

`geom_smooth()` creates a "smooth line" to the data points. This function is often used to display trend lines. By setting the `method` argument to `lm`, `geom_smooth()` fits the data to a straight line, with the use of linear regression. 


### Exercise 10

Coy the previous code. Inside `geom_smooth()`, set `se` to `FALSE` and `alpha` to `0.5`.

```{r modeling-in-base-r-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r modeling-in-base-r-10-hint-1, eval = FALSE}
geom_smooth(method = "lm", se = ..., alpha = ... )
```

```{r include = FALSE}
crickets |>
  ggplot(aes(x = temp, 
             y = rate, 
             color = species, 
             pch = species, 
             lty = species)) +
    geom_point(size = 2) + 
      geom_smooth(method = "lm", se = FALSE, alpha = 0.5)
```

### 

The `se` argument stands for  "standard error," and it controls the display of the confidence interval, which is the uncertainty range of the relationship of the data, around the fitted line or curve. `se` is represented by the gray tint on the line. By setting `se` to `FALSE`, that gray tint goes away.

The `alpha` argument controls the opacity of the line on the graph. 

### Exercise 11

Next, lets change the color scheme of the graph using `scale_colour_brewer()`. Copy the the previous code and add `scale_colour_brewer()`. Inside this function, set `palette` to `"Paired"`.

```{r modeling-in-base-r-11, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r modeling-in-base-r-11-hint-1, eval = FALSE}
... +
  scale_colour_brewer(... = "...")
```

```{r include = FALSE}
crickets |>
  ggplot(aes(x = temp, 
             y = rate, 
             color = species, 
             pch = species, 
             lty = species)) +
    geom_point(size = 2) + 
      geom_smooth(method = "lm") + 
         scale_color_brewer(palette = "Paired")
```

### 

As you can see, the colors have been changed to a lighter and darker blue. Click [here](https://ggplot2.tidyverse.org/reference/scale_brewer.html) to learn more about the ColorBrewer.

### Exercise 12

Copy the previous code and add your `labs()`. The final graph should look like this:

```{r}
crickets_plot
```

```{r modeling-in-base-r-12, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r modeling-in-base-r-12-hint-1, eval = FALSE}
... + 
  labs(
    x = "...",
    y = "..."
  )
```

### 

The data exhibit fairly linear trends for each species. For a given temperature, *O. exclamationis* appears to chirp more per minute than the other species. For an inferential model, the researchers might have specified the following null hypotheses prior to seeing the data:

-   Temperature has no effect on the chirp rate.

-   There are no differences between the species' chirp rate.

There may be some scientific or practical value in predicting the chirp rate but in this example we will focus on inference.

### Exercise 13

To fit an ordinary linear model in R, the `lm()` function is commonly used. The important arguments to this function are a model formula and a data frame that contains the data (and note that the formula is *symbolic*.)

Lets create a fitted linear model using the `crickets` data frame. In the code chunk below, type in `lm()`. Set `formula` to `rate ~ temp` and `data` to `crickets`.

```{r modeling-in-base-r-13, exercise = TRUE}

```

```{r modeling-in-base-r-13-hint-1, eval = FALSE}
...(formula = ... ~ ..., data = ...)
```

```{r include = FALSE}
lm(formula = rate ~ temp, data = crickets)
```

### 

The `rate ~ temp` specifies that the chirp rate is the outcome (since it is on the left-hand side of the tilde `~`) and that the temperature value is the predictor.

### Exercise 14

Suppose the data contained the time of day in which the measurements were obtained in a column called `time`.

Here's what the formula would look like:

```
rate ~ temp + time
```

### 

A common misunderstanding is that this formula would add the time and temperature values together. What this formula would actually do is symbolically represent that temperature and time should be added as separate *main effects* to the model. 

A *main effect* is a model term that contains a single predictor variable.

### Exercise 15

Lets add `species` to our fitted model. Copy the code from Exercise 13 and add `speices` after `temp`.

```{r modeling-in-base-r-15, exercise = TRUE}

```

```{r modeling-in-base-r-15-hint-1, eval = FALSE}
lm(formula = rate ~ temp + ..., data = crickets)
```

```{r include = FALSE}
lm(formula = rate ~ temp + species, data = crickets)
```

### 

Note that the vast majority of model functions cannot operate on non-numeric data (`species` is non-numeric). For species, the model needs to encode the species data in a numeric format.

The most common approach is to use indicator variables (a.k.a. dummy variables) in place of the original qualitative values. In this instance, since species has two possible values, the model formula will [automatically encode]{.underline} this column as numeric by adding a new column that has a value of zero when the species is `"O. exclamationis"` and a value of one when the data correspond to `"O. niveus"`.

### Exercise 16

When creating this fitted linear model, the slopes of the regression lines could be different for each species. To accomodate for this, we can add an interaction term.

Copy paste the code from above. After `species`, type in `+ temp:species`.

```{r modeling-in-base-r-16, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r modeling-in-base-r-16-hint-1, eval = FALSE}
lm(formula = rate ~ temp + species + ... : ..., data = crickets)
```

```{r include = FALSE}
lm(formula = rate ~ temp + species + temp:species, data = crickets)
```

### 

An interaction term is where two (or more) variables interact to affect a third variable.

### Exercise 17

<!-- DK: These should be two exercises, with instructions. Students should type. Done -->

There are some shortcuts to achieve what was done in the previous exercise. Copy the code from the previous exercise and change `rate ~ temp + species + temp:species` to `rate ~ temp * species`.

```{r modeling-in-base-r-17, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r modeling-in-base-r-17-hint-1, eval = FALSE}
lm(formula = rate ~ ... * ..., data = crickets)
```

```{r include = FALSE}
lm(formula = rate ~ temp * species, data = crickets)
```

### 

In addition to the convenience of automatically creating indicator variables, the formula offers a few other niceties, such as using other functions in the formula argument (ex: `log()` and `poly()`) and using the period shortcut (`~ (.)^3`).

### Exercise 18

Lets look at another shortcut we can use. Copy the previous code and change `rate ~ temp * species` to `rate ~ (temp + species)^2`.

```{r modeling-in-base-r-18, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r modeling-in-base-r-18-hint-1, eval = FALSE}
lm(formula = rate ~ (... + ...)^2, data = crickets)
```

```{r include = FALSE}
lm(formula = rate ~ (temp + species)^2, data = crickets)
```

### 

the `lm()` function can be passed in with multiple arguments, such as `offset` and `method`. Check out the `lm()` help page to learn more. 


### Exercise 19

Now, lets use our fitted model to make plots. Copy the previous code and  save it to the variable `interaction_fit`.

```{r modeling-in-base-r-19, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r modeling-in-base-r-19-hint-1, eval = FALSE}
... <- lm(formula = rate ~ (temp + species)^2, data = crickets)
```

```{r include = FALSE}
interaction_fit <- lm(formula = rate ~ (temp + species)^2, data = crickets)
```

### 

In this tutorial, the suffix `_fit` will be used for R objects that are fitted models.

### Exercise 20

Type in `plot()` and pass in `interaction_fit`.

```{r modeling-in-base-r-20, exercise = TRUE}

```

```{r modeling-in-base-r-20-hint-1, eval = FALSE}
plot(...)
```

```{r include = FALSE}
plot(interaction_fit)
```

### 

This method produces a set of four plots for the object, each showing different aspects of the fitted object.

### Exercise 21

Our next order of business with the crickets is to assess if the inclusion of the interaction term is necessary. The most appropriate approach for this model is to recompute the model without the interaction term and use the `anova()` method.

Copy the model from Exercise 11 and save it to the variable `main_effect_fit`.

```{r modeling-in-base-r-21, exercise = TRUE}

```

```{r modeling-in-base-r-21-hint-1, eval = FALSE}
... <- lm(...)
```

```{r include = FALSE}
main_effect_fit <-  lm(rate ~ temp + species, data = crickets) 
```

### 

When it comes to the technical details of evaluating expressions, R is lazy (as opposed to eager). This means that model fitting functions typically compute the minimum possible quantities at the last possible moment. For example, if you are interested in the coefficient table for each model term, this is not automatically computed with the model but is instead computed via the `summary()` method.

### Exercise 22

In order to assess the necessity of the interaction variable, we need to use the `anova()` function. Type in `?anova()` to the Console and look at the Description section. CP/CR.

```{r modeling-in-base-r-22}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

The `anova()` function takes in fitted objects as arguments, like the `main_effect_fit` and `interactive_fit` objects we created earlier.

### Exercise 23

Pass in `main_effect_fit` and `interactive_fit` to the `anova()` function. Press "Run Code" when done. 

```{r modeling-in-base-r-23, exercise = TRUE}

```

```{r modeling-in-base-r-23-hint-1, eval = FALSE}
anova(..., ...)
```

### 

This function displays a series of statistical information. Looking towards the bottom right of the output, you will see the number `0.25`. This number represents the p-value. 

The p-value determines the statistical significance of the data; a p-value of < 0.05 means that the data *is* statistically significant. However, this data produced a p-value of `0.25`, implying a lack of evidence against the null hypothesis that the interaction term is not needed by the model.

### Exercise 24

Because of the p-value, we need to conduct further analysis on the model without the use of the interaction variable (which is `species`).

Using the `summary()` will help. In the code chunk below, type in `summary()`, passing in `main_effect_fit`.

```{r modeling-in-base-r-24, exercise = TRUE}

```

```{r modeling-in-base-r-24-hint-1, eval = FALSE}
summary(...)
```

```{r include = FALSE}
summary(main_effect_fit)
```

### 

The chirp rate for each species increases by 3.6 chirps as the temperature increases by a single degree. This term shows strong statistical significance as evidenced by the p-value. The species term has a value of -10.07. This indicates that, across all temperature values, `O. niveus` has a chirp rate that is about 10 fewer chirps per minute than `O. exclamationis`. Similar to the temperature term, the species effect is associated with a very small p-value.

### Exercise 25

If we want to calculate the chirp rate at a temperature that was not observed in the experiment, we can use the `predict()` method. Run `?predict()` in the Console and look at the Description section. CP/CR

```{r modeling-in-base-r-25}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

The `predict()` function the model object and a data frame of new values in order to make predictions.

### Exercise 26

Lets make the data frame of new values, which we need in order to use `predict()`. In the code chunk below, type in `data.frame()`. Set `species` to `"O. exclamationis"` and `temp` to `15:20`. Save the code to the variable `new_values`.

```{r modeling-in-base-r-26, exercise = TRUE}

```

```{r modeling-in-base-r-26-hint-1, eval = FALSE}
... <- ...(... = "O. exclamationis", temp = ...)
```

```{r include = FALSE}
new_values <- data.frame(species = "O. exclamationis", temp = 15:20)
```

### 

This model will estimate the chirp rate for `O. exclamationis` for temperatures between 15° C and 20° C.

### Exercise 27

Now lets estimate the predicted values. Type in `predict()`, passing in `main_effect_fit` and `new_values`. 

```{r modeling-in-base-r-27, exercise = TRUE}

```

```{r modeling-in-base-r-27-hint-1, eval = FALSE}
predict(..., ...)
```

```{r include = FALSE}
predict(main_effect_fit, new_values)
```

### 

All the displayed numbers are predicted chirp rates of the `O. exclamationis` species for temperatures between 15° C and 20° C.

### 

If you are confused about the R model formula and its functionality, visit [this link](https://www.tmwr.org/base-r.html#formula).


## Model Implementation
### 

One of the strengths of R is that it encourages developers to create a user interface that fits their needs. 

### Exercise 1

Let's use one of the three common methods for creating a scatter plot, using the `crickets` tibble. In the code chunk below, type in `crickets` and pipe it to `ggplot()`.

```{r model-implementation-1, exercise = TRUE}

```

```{r model-implementation-1-hint-1, eval = FALSE}
... |>
  ggplot()
```

```{r include = FALSE}
crickets |>
  ggplot()
```

### 

Instead of piping the `crickets` tibble to `ggplot()`, you can also set the `data` argument inside `ggplot()` to `crickets`.

### Exercise 2

Copy the previous code.Inside `ggplot()`, type in `aes()`. Set `x` to `temp` and `y` to `rate`.

```{r model-implementation-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r model-implementation-2-hint-1, eval = FALSE}
crickets |>
  ggplot(aes(... = temp, y = ...))
```

```{r include = FALSE}
crickets |>
  ggplot(aes(x = temp, y = rate))
```

### 

The 3 most common types of models are descriptive models, predictive models, and inferential models. Descriptive models describe or illustrate characteristics of data, predictive models predicts new data, and inferential models produce a decision for a research question or to explore a specific hypothesis.

### Exercise 3

Copy the previous code and add `geom_point()`.

```{r model-implementation-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r model-implementation-3-hint-1, eval = FALSE}
... + 
  geom_point()
```

```{r include = FALSE}
crickets |>
  ggplot(aes(x = temp, y = rate)) + 
    geom_point()
```

### 

As you can see, this code creates a simple scatter plot of the crickets` chirp rate and temperature.

### Exercise 4

Let's look another common method of creating a scatter plot, this time using the base R function, `plot()`. In the code chunk below, type in `plot()`. Pass in `crickets$temp` and `crickets$rate`.

```{r model-implementation-4, exercise = TRUE}

```

```{r model-implementation-4-hint-1, eval = FALSE}
plot(... , ...)
```

```{r include = FALSE}
plot(crickets$temp, crickets$rate)
```

### 

The `$` operator is can be used to extract a specific column from a dataframe. In this case, `crickets$temp` extracts the temperature column and `crickets$rate` extracts the cricket chirp rate column.

### Exercise 5

We can also use the **lattice** library to create a scatterplot of the `crickets` tibble. In the code chunk below, load the **lattice** package using `library()`.

```{r model-implementation-5, exercise = TRUE}

```

```{r model-implementation-5-hint-1, eval = FALSE}
library(...)
```

```{r include = FALSE}
library(lattice)
```

### 

The **lattice** library utilizes a formula based interface in order to create graphs and plots. 

### Exercise 6

We will be using the `xyplot()` function from the **lattice** package in order to make this graph. In the code chunk below, type in `xyplot()`. Type in `rate` ~ temp`. Then, set the `data` argument to `crickets`. 

```{r model-implementation-6, exercise = TRUE}

```

```{r model-implementation-6-hint-1, eval = FALSE}
xyplot(... ~ ..., data = ...)
```

```{r include = FALSE}
xyplot(rate ~ temp, data = crickets)
```

### 

An advantage of R’s diversity of interfaces is that it can evolve over time and fit different needs for different users. As you can see from the previous exercise, each of these distinct plotting methods all display the same result: a scatterplot of a crickets temperature and chirp rate.

Unfortunately, some of the syntactical diversity is due to a focus on the needs of the person *developing* the code instead of the needs of the person *using* the code. Inconsistencies among packages can be a stumbling block for R users.

### Exercise 7

A disadvantage to the R language is its lack of consistency. For example, R has many different ways of handling missing values. Lets observe these different methods, using the models we created in the previous section.

In the code chunk below, type in `NA` and set it to `new_values$temp[1]` using the `<-` operator.

```{r model-implementation-7, exercise = TRUE}

```

```{r model-implementation-7-hint-1, eval = FALSE}
... <- NA
```

```{r include = FALSE}
new_values$temp[1] <- NA
```

### 

The single bracket operator, `[`, is used for indexing into a vector, matrix, list, dataframe, etc. 

This code adds an `NA` value in the first index of `new_values`. `NA` represents a missing value. 

### Exercise 8

Copy the previous code. On a new line, type `predict()` and pass in `main_effect_fit` and `new_values`.

```{r model-implementation-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r model-implementation-8-hint-1, eval = FALSE}
predict(... , ...)
```

```{r include = FALSE}
predict(main_effect_fit, new_values)
```

### 

As you can see, the `predict()` function takes in the `NA` value without throwing any error. This is because for linear models, the `predict()` function has a default parameter, called `na.action`, that is set to `na.pass` by default. This means that the `predict()` function, by default, accepts the missing values. 

### Exercise 9

We can edit the `na.action` parameter to handle missing values in different ways. Copy the previous code and set the `na.action` parameter to `na.fail` (Note: This is intended to throw an error).

```{r model-implementation-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r model-implementation-9-hint-1, eval = FALSE}
predict(main_effect_fit, new_values, ... = ...)
```

```{r include = FALSE}
# predict(main_effect_fit, new_values, na.action = na.fail)
```

### 

The purpose of `na.fail` is to throw an error if the data contains any missing (`NA`) values.

### Exercise 10

Another way to use `na.action` to handle missing values is to not include them at all. Copy the previous code and change `na.fail` to `na.omit`.

```{r model-implementation-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r model-implementation-10-hint-1, eval = FALSE}
predict(main_effect_fit, new_values, na.action = ...)
```

```{r include = FALSE}
predict(main_effect_fit, new_values, na.action = na.omit)
```

### 

Note that the 1st index is not included in the output. From a user’s point of view, `na.omit` can be problematic. In our example, `new_values` has 6 rows but only 5 would be returned with `na.omit`. To adjust for this, the user would have to determine which row had the missing value and interleave a missing value in the appropriate place if the predictions were merged into `new_values`.

### 

To resolve this issue, the tidymodels packages have created a set of design goals. Many of their ideas are described in the tidymodels guidelines for [model implementation](https://tidymodels.github.io/model-implementation-principles/index.html).

### Exercise 11

Lets explore another tool for standardizing the structure of R objects: the **broom** library and `tidy()` function. Load the **broom** library below.


```{r model-implementation-11, exercise = TRUE}

```

```{r model-implementation-11-hint-1, eval = FALSE}
library(...)
```

```{r include = FALSE}
library(broom)
```

### 

The `tidy()` function, which comes from the **broom** package, can return many types of R objects in a more usable format.

### Exercise 12

We will be using the `mtcars` dataset from the **dplyr** package. In the code chunk below, type `mtcars` and press "Run Code".

```{r model-implementation-12, exercise = TRUE}

```

```{r include = FALSE}
mtcars
```

### 

<!-- AK: Add Knowledge Drop -->



## Summary
### 

This chapter reviewed core R language conventions for creating and using models that are an important foundation for the rest of this book. The formula operator is an expressive and important aspect of fitting models in R and often serves multiple purposes in non-tidymodels functions. Traditional R approaches to modeling have some limitations, especially when it comes to fluently handling and visualizing model output. The **tidymodels** metapackage applies tidyverse design philosophy to modeling packages.


```{r download-answers, child = system.file("child_documents/download_answers.Rmd", package = "tutorial.helpers")}
```
