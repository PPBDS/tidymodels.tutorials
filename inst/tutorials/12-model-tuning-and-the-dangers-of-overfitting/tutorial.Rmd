---
title: Model Tuning and the Dangers of Overfitting
author: Aryan Kancherla
tutorial:
  id: model-tuning-and-the-dangers-of-overfitting
output:
  learnr::tutorial:
    progressive: yes
    allow_skip: yes
runtime: shiny_prerendered
description: 'Tutorial for Chapter 12: Model Tuning and the Dangers of Overfitting'
---

```{r setup, include = FALSE, warning = FALSE}
library(learnr)
library(tutorial.helpers)
library(knitr)
library(tidymodels)
tidymodels_prefer()

knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 60, 
        tutorial.storage = "local") 

split <- initial_split(two_class_dat)
training_set <- training(split)
testing_set <- testing(split)

llhood <- function(...) {
  logistic_reg() |> 
    set_engine("glm", ...) |>
    fit(Class ~ ., data = training_set) |> 
    glance() |> 
    select(logLik)
}


set.seed(1201)

rs <- vfold_cv(training_set, repeats = 10)

lloss <- function(...) {
  perf_meas <- metric_set(roc_auc, mn_log_loss)
    
  logistic_reg() |> 
    set_engine("glm", ...) |>
    fit_resamples(Class ~ A + B, rs, metrics = perf_meas) |>
    collect_metrics(summarize = FALSE) |>
    select(id, id2, .metric, .estimate)
}

resampled_res <- 
  bind_rows(
  lloss() |> mutate(model = "logistic"),
  lloss(family = binomial(link = "probit")) |> mutate(model = "probit"),
  lloss(family = binomial(link = "cloglog")) |> mutate(model = "c-log-log")
) |>
  mutate(.estimate = ifelse(.metric == "mn_log_loss", -.estimate, .estimate)) |>
  group_by(model, .metric) |>
  summarize(
    .groups = "drop",
    mean = mean(.estimate, na.rm = TRUE),
    std_err = sd(.estimate, na.rm = TRUE) / sqrt(n())
)

logLikelihoodPlot <- 
  resampled_res |> 
  filter(.metric == "mn_log_loss") |>
  ggplot(aes(x = mean, y = model)) +
  geom_point() +
  geom_errorbar(aes(xmin = mean - 1.64 * std_err, xmax = mean + 1.64 * std_err, width = 0.1)) +
  labs(
    x = "log-likelihood",
    y = NULL
  )

neural_net_spec <- 
  mlp(hidden_units = tune()) |>
  set_mode("regression") |>
  set_engine("keras")

```

```{r copy-code-chunk, child = system.file("child_documents/copy_button.Rmd", package = "tutorial.helpers")}
```

```{r info-section, child = system.file("child_documents/info_section.Rmd", package = "tutorial.helpers")}
```

## Introduction
### 

This tutorial covers [Chapter 12: Model Tuning and the Dangers of Overfitting](https://www.tmwr.org/tuning.html) from [*Tidy Modeling with R*](https://www.tmwr.org/) by Max Kuhn and Julia Silge. 

## What do we Optimize?
### 

In order to use a model for prediction, the parameters for that model must be estimated. Some of these parameters can be estimated directly from the training data, but other parameters, called tuning parameters or *hyperparameters*, must be specified ahead of time and can’t be directly found from training data. These are unknown structural or other kind of values that have significant impact on the model but cannot be directly estimated from the data. 

### Exercise 1

Load the **tidymodels** library using `library()`.

```{r what-do-we-optimize-1, exercise = TRUE}

```

```{r what-do-we-optimize-1-hint-1, eval = FALSE}
library(...)
```

```{r include = FALSE}
library(tidymodels)
```

### 

In ordinary linear regression, there are two parameters $\beta_0$ and $\beta_1$ of the model: 

$$ y_i = \beta_0 + \beta_1 x_i + \epsilon_i$$ 

When we have the outcome ($y$) and predictor ($x$) data, we can estimate the two parameters $\beta_0$ and $\beta_1$: 

$$\hat \beta_1 = \frac{\sum_i (y_i-\bar{y})(x_i-\bar{x})}{\sum_i(x_i-\bar{x})^2}$$ 

and

$$\hat \beta_0 = \bar{y}-\hat \beta_1 \bar{x}.$$

We can directly estimate these values from the data for this example model because they are analytically tractable; if we have the data, then we can estimate these model parameters. 

### Exercise 2

Type in `tidymodels_prefer()` to get rid of naming conflicts.

```{r what-do-we-optimize-2, exercise = TRUE}

```

```{r what-do-we-optimize-2-hint-1, eval = FALSE}
...()
```

```{r include = FALSE}
tidymodels_prefer()
```

### 

For the KNN model, the prediction equation for a new value $x_0$ is

$$\hat y = \frac{1}{K}\sum_{\ell = 1}^K x_\ell^*$$

where $K$ is the number of neighbors and the $x_\ell^*$ are the $K$ closest values to $x_0$ in the training set.


The model itself is not defined by a model equation; the previous prediction equation instead defines it. This characteristic, along with the possible intractability of the distance measure, makes it impossible to create a set of equations that can be solved for $K$ (iteratively or otherwise). The number of neighbors has a profound impact on the model; it governs the flexibility of the class boundary. For small values of $K$, the boundary is very elaborate while for large values, it might be quite smooth.


### Exercise 3

The `two_class_dat` data frame will be used in this section. In the code chunk below, type in `two_class_dat`.

```{r what-do-we-optimize-3, exercise = TRUE}

```

```{r what-do-we-optimize-3-hint-1, eval = FALSE}
two_class_dat
```

```{r include = FALSE}
two_class_dat
```

### 

How should we evaluate models when we optimize tuning parameters? It depends on the model and the purpose of the model. For cases where the statistical properties of the tuning parameter are tractable, common statistical properties can be used as the objective function. For example, in the case of binary logistic regression, the link function can be chosen by maximizing the likelihood or information criteria. However, these statistical properties may not align with the results achieved using accuracy-oriented properties.


### Exercise 4

The `two_class_dat` data frame contains artificial data with two predictors (`A` and `B`) and a factor outcome variable (`Class`). Now, lets create a split of this data. In the code chunk below, type in `initial_split()` and pass the `two_class_dat` data frame inside the function.

```{r what-do-we-optimize-4, exercise = TRUE}

```

```{r what-do-we-optimize-4-hint-1, eval = FALSE}
initial_split(...)
```

```{r include = FALSE}
initial_split(two_class_dat)
```

### 

As an example, Jerome H. Friedman, one of the world's leading researchers in statistics and data mining, optimized the number of trees in a boosted tree ensemble and found different results when maximizing the likelihood and accuracy:

"Degrading the likelihood by overfitting actually improves misclassification error rate. Although perhaps counterintuitive, this is not a contradiction; likelihood and error rate measure different aspects of fit quality."

### Exercise 5

Copy the previous code and assign it to a new variable called `split`.

```{r what-do-we-optimize-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r what-do-we-optimize-5-hint-1, eval = FALSE}
... <- initial_split(two_class_dat)
```

```{r include = FALSE}
split <- initial_split(two_class_dat)
```

### 

There are many situations where a model has parameters that can’t be directly estimated from the data.

### Exercise 6

Next, lets extract the training set from `split`. In the code chunk below, type in `training()`, passing in `split`.

```{r what-do-we-optimize-6, exercise = TRUE}

```

```{r what-do-we-optimize-6-hint-1, eval = FALSE}
...(split)
```

```{r include = FALSE}
training(split)
```

### 

To demonstrate, consider the classification data shown in the graph below with two predictors, two classes, and a training set of 593 data points:

```{r}
knitr::include_graphics("images/pic1.png")
```

To start, a linear class boundary to these data could be fitted. The most common method for doing this is to use a generalized linear model in the form of logistic regression. This model relates the log odds of a sample being Class 1 using the logit transformation:

$$ \log\left(\frac{\pi}{1 - \pi}\right) = \beta_0 + \beta_1x_1 + \ldots + \beta_px_p$$

### Exercise 7

Copy the previous code and assign it to a new variable called `training_set`.

```{r what-do-we-optimize-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r what-do-we-optimize-7-hint-1, eval = FALSE}
... <- training(split)
```

```{r include = FALSE}
training_set <- training(split)
```

### 

In the context of generalized linear models, the logit function is the _link function_ between the outcome ($\pi$) and the predictors. There are other link functions that include the _probit_ model: 

$$\Phi^{-1}(\pi) = \beta_0 + \beta_1x_1 + \ldots + \beta_px_p$$

where $\Phi$ is the cumulative standard normal function, as well as the _complementary log-log_ model:

$$\log(-\log(1-\pi)) = \beta_0 + \beta_1x_1 + \ldots + \beta_px_p$$

### Exercise 8

Now, lets create a testing set of `split`. Type in `testing()`, passing in `split`.

```{r what-do-we-optimize-8, exercise = TRUE}

```

```{r what-do-we-optimize-8-hint-1, eval = FALSE}
testing(...)
```

```{r include = FALSE}
testing(split)
```

### 

Each of these models results in linear class boundaries. Which one should we use? Since, for these data, the number of model parameters does not vary, the statistical approach is to compute the (log) likelihood for each model and determine the model with the largest value. Traditionally, the likelihood is computed using the same data that were used to estimate the parameters, not using approaches like data splitting or resampling.

### Exercise 9

Copy the previous code and assign it to a new variable named `testing_set`.

```{r what-do-we-optimize-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r what-do-we-optimize-9-hint-1, eval = FALSE}
... <- testing(split)
```

```{r include = FALSE}
testing_set <- testing(split)
```

### 

There are many examples of tuning parameters or hyperparameters in different statistical and machine learning models. One of which is boosting. Boosting is an ensemble method that combines a series of base models, each of which is created sequentially and depends on the previous models. The number of boosting iterations is an important tuning parameter that usually requires optimization.

### Exercise 10

Using the `training_set` data frame, let’s create a function to compute the different models and extract the likelihood statistics for the training set. In the code chunk below, type in `function(...){}`.

```{r what-do-we-optimize-10, exercise = TRUE}

```

```{r what-do-we-optimize-10-hint-1, eval = FALSE}
# Leave the three dots inside the parenthesis of the function
function(...) {
  
}
```

```{r include = FALSE}
function(...) {
  
}
```

### 

In the classic single-layer artificial neural network (a.k.a. the multilayer perceptron), the predictors are combined using two or more hidden units. The hidden units are linear combinations of the predictors that are captured in an *activation function* (typically a nonlinear function, such as a sigmoid).

### Exercise 11

Copy the previous code. Inside the funciton, pipe `logistic_reg()` to `set_engine()`. Inside `set_engine()`, pass in `"glm"` and `...`.

```{r what-do-we-optimize-11, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r what-do-we-optimize-11-hint-1, eval = FALSE}
function(...) {
  logistic_reg() |>
    set_engine("...", ...)
}
```

```{r include = FALSE}
function(...) {
  logistic_reg() |>
    set_engine("glm", ...)
}
```

### 

The hidden units are then connected to the outcome units; one outcome unit is used for regression models, and multiple outcome units are required for classification. The number of hidden units and the type of activation function are important structural tuning parameters.

### Exercise 12

Copy the previous code and continue the pipe to `fit()`. Inside `fit()`, type in `Class ~ .` and set `data` to `training_set` (Note: Leave the three dots inside `set_engine()`; don't remove them).

```{r what-do-we-optimize-12, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r what-do-we-optimize-12-hint-1, eval = FALSE}
function(...) {
  logistic_reg() |>
    set_engine("glm", ...) |>
    fit(Class ~ ., ... = ...)
}
```

```{r include = FALSE}
function(...) {
  logistic_reg() |>
    set_engine("glm", ...) |>
    fit(Class ~ ., data = training_set)
}
```

### 

Modern gradient descent methods are improved by finding the right optimization parameters. Examples of such hyperparameters are learning rates, momentum, and the number of optimization iterations/epochs.

### Exercise 13

Copy the previous code and continue the pipe to `glance()`.

```{r what-do-we-optimize-13, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r what-do-we-optimize-13-hint-1, eval = FALSE}
function(...) {
  logistic_reg() |>
    set_engine("glm", ...) |>
    fit(Class ~ ., data = training_set) |>
    ...()
}
```

```{r include = FALSE}
function(...) {
  logistic_reg() |>
    set_engine("glm", ...) |>
    fit(Class ~ ., data = training_set) |>
    glance()
}
```

### 

`glance()` is a function that is used to extract a tidy summary of model fit statistics from a variety of model objects, such as linear regression, generalized linear models, mixed-effects models, and more.

### Exercise 14

Copy the previous code and continue the pipe to `select()`. Inside `select()`, pass in `logLik`.

```{r what-do-we-optimize-14, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r what-do-we-optimize-14-hint-1, eval = FALSE}
function(...) {
  logistic_reg() |>
    set_engine("glm", ...) |>
    fit(Class ~ ., data = training_set) |>
    glance() |>
    ...(logLik)
}
```

```{r include = FALSE}
function(...) {
  logistic_reg() |>
    set_engine("glm", ...) |>
    fit(Class ~ ., data = training_set) |>
    glance() |>
    select(logLik)
}
```

### 

Neural networks and some ensemble models use gradient descent to estimate the model parameters. While the tuning parameters associated with gradient descent are not structural parameters, they often require tuning.

### Exercise 15

Copy the previous code and assign the entire function to a new variable named `llhood`.

```{r what-do-we-optimize-15, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r what-do-we-optimize-15-hint-1, eval = FALSE}
... <- function(...) {
  logistic_reg() |>
    set_engine("glm", ...) |>
    fit(Class ~ ., data = training_set) |>
    glance() |>
    select(logLik)
}
```

```{r include = FALSE}
llhood <- function(...) {
  logistic_reg() |>
    set_engine("glm", ...) |>
    fit(Class ~ ., data = training_set) |>
    glance() |>
    select(logLik)
}
```

### 

In some cases, preprocessing techniques require tuning:

In principal component analysis, or its supervised cousin called partial least squares, the predictors are replaced with new, artificial features that have better properties related to collinearity. The number of extracted components can be tuned.

### Exercise 16

Now, lets use this newly created function along with the `bind_rows()` function. `bind_rows()` is used to bind any number of data frames by row, creating a longer result.

In the code chunk below, type in `bind_rows()`. Inside this function, type in `llhood()`.

```{r what-do-we-optimize-16, exercise = TRUE}

```

```{r what-do-we-optimize-16-hint-1, eval = FALSE}
bind_rows(
  ...()
)
```

```{r include = FALSE}
bind_rows(
  llhood()
)
```

### 

Imputation methods estimate missing predictor values using the complete values of one or more predictors. One effective imputation tool uses $K$-nearest neighbors of the complete columns to predict the missing value. The number of neighbors modulates the amount of averaging and can be tuned.  

### Exercise 17

Copy the previous code and as the second argument of `bind_rows()`, type in `llhood()` again. Inside this function, set `family` to `binomial(link = "probit")`.

```{r what-do-we-optimize-17, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r what-do-we-optimize-17-hint-1, eval = FALSE}
bind_rows(
  llhood(),
  llhood(family = ...(link = "..."))
)
```

```{r include = FALSE}
bind_rows(
  llhood(),
  llhood(family = binomial(link = "probit"))
)
```

### 

This part of the code is calling the `llhood()` function, but this time it is specifying a different model. It uses the binomial family with a probit link function, suggesting that this log-likelihood calculation is for a binomial regressioin model with a probit link. Type in `?binomial()` in the Console to learn more.

### Exercise 18

Copy the previous code and as the third argument of `bind_rows()`, type in `llhood()` yet again. Inside this function, set `family` to `binomial(link = "cloglog")`.

```{r what-do-we-optimize-18, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r what-do-we-optimize-18-hint-1, eval = FALSE}
bind_rows(
  llhood(),
  llhood(family = binomial(link = "probit")),
  llhood(family = ...(link = "..."))
)
```

```{r include = FALSE}
bind_rows(
  llhood(),
  llhood(family = binomial(link = "probit")),
  llhood(family = binomial(link = "cloglog"))
)
```

### 

"cloglog" stands *complementary log-log*.

Also, `logLik` stands for "log-likelihood," and it is a measure used to assess how well a statistical model fits a given dataset.

### Exercise 19

Copy the previous code and pipe the entire `bind_rows()` function to `mutate()`. Inside `mutate()`, set `link` to a vector containing `"logit"`, `"probit"`, and `"c-log-log"` (use `c()` to create a vector).

```{r what-do-we-optimize-19, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r what-do-we-optimize-19-hint-1, eval = FALSE}
bind_rows(
  llhood(),
  llhood(family = binomial(link = "probit")),
  llhood(family = binomial(link = "cloglog"))
) |>
  mutate(link = c("...", "...", "..."))
  
```

```{r include = FALSE}
bind_rows(
  llhood(),
  llhood(family = binomial(link = "probit")),
  llhood(family = binomial(link = "cloglog"))
) |>
  mutate(link = c("logit", "probit", "c-log-log"))
```

### 

According to these results, the logistic model has the best statistical properties.

From the scale of the log-likelihood values, it is difficult to understand if these differences are important or negligible. One way of improving this analysis is to resample the statistics and separate the modeling data from the data used for performance estimation.

### Exercise 20

With this small data set, repeated 10-fold cross-validation is a good choice for resampling. In the yardstick package, the `mn_log_loss()` function is used to estimate the negative log-likelihood.

Lets perform this negative log-likelihood estimation. In the code chunk below, type in `set.seed(1201)`.

```{r what-do-we-optimize-20, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r what-do-we-optimize-20-hint-1, eval = FALSE}
...(1201)
```

```{r include = FALSE}
set.seed(1201)
```

### 

Some classical statistical models also have structural parameters:

In binary regression, the logit link is commonly used (i.e., logistic regression). Other link functions, such as the probit and complementary log-log, are also available.

### Exercise 21

Lets start by creating a 10-fold-cross-validation. In the code chunk below, type in `vfold_cv()`, passing in `training_set` and setting `repeats` to `10`. 

```{r what-do-we-optimize-21, exercise = TRUE}

```

```{r what-do-we-optimize-21-hint-1, eval = FALSE}
vfold_cv(..., repeats = ...)
```

```{r include = FALSE}
vfold_cv(training_set, repeats = 10)
```

### 

As a reminder, a 10-fold-cross-validation set is when ten iterations of resampling are issued. In this case, since V = 10, the analysis sets are 9/10 of the training set and each assessment set is a distinct 1/10.

### Exercise 22

Copy the previous code and assign it to a new variable named `rs`.

```{r what-do-we-optimize-22, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r what-do-we-optimize-22-hint-1, eval = FALSE}
... <- vfold_cv(training_set, repeats = 10)
```

```{r include = FALSE}
rs <- vfold_cv(training_set, repeats = 10)
```

### 

A counterexample where it is inappropriate to tune a parameter is the prior distribution required for Bayesian analysis. The prior encapsulates the analyst’s belief about the distribution of a quantity before evidence or data are taken into account.


### Exercise 23

Next, create a new function. Inside the function, set the code `metric_set(roc_auc, mn_log_loss)` to the variable `perf_meas`.

```{r what-do-we-optimize-23, exercise = TRUE}

```

```{r what-do-we-optimize-23-hint-1, eval = FALSE}
function(...){
  ... <- metric_set(..., mn_log_loss)
}
```

```{r include = FALSE}
function(...) {
  perf_meas <- metric_set(roc_auc, mn_log_loss)
}
```

### 

`metric_set()` is a function that calculates the logarithmic loss of a classification model. Click [here](https://yardstick.tidymodels.org/reference/mn_log_loss.html) to learn more. 

### Exercise 24

Copy the previous code. On a new line inside the function, pipe `logistic(reg)` to `set_engine()`. Inside `set_engine()`, type in `"glm", ...`.

```{r what-do-we-optimize-24, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r what-do-we-optimize-24-hint-1, eval = FALSE}
function(...) {
  perf_meas <- metric_set(roc_auc, mn_log_loss)
  
  logistic_reg() |>
    ...("...", ...)
}
```

```{r include = FALSE}
function(...) {
  perf_meas <- metric_set(roc_auc, mn_log_loss)
    
  logistic_reg() |> 
    set_engine("glm", ...)
}
```

### 

For example, in [Section 11.4](https://www.tmwr.org/compare#tidyposterior) of [*Tidy Modeling with R*](https://www.tmwr.org/index.html), a Bayesian ANOVA model as used, and it was unclear about what the prior should be for the regression parameters (beyond being a symmetric distribution). A t-distribution was chosen with one degree of freedom for the prior since it has heavier tails; this reflects our added uncertainty. The prior beliefs should not be subject to optimization. Tuning parameters are typically optimized for performance whereas priors should not be tweaked to get “the right results.”

### Exercise 25

Copy the previous code and continue the pipe to `fit_resamples()`. Inside `fit_resamples()`, type in `Class ~ A + B, rs` as the first argument, `rs` as the second argument, and set `metrics` to `perf_meas` as the third argument.

```{r what-do-we-optimize-25, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r what-do-we-optimize-25-hint-1, eval = FALSE}
function(...) {
  perf_meas <- metric_set(roc_auc, mn_log_loss)
    
  logistic_reg() |> 
    set_engine("glm", ...) |>
    fit_resamples(Class ~ A + B, ... , metrics = ...)
}
```

```{r include = FALSE}
function(...) {
  perf_meas <- metric_set(roc_auc, mn_log_loss)
    
  logistic_reg() |> 
    set_engine("glm", ...) |>
    fit_resamples(Class ~ A + B, rs, metrics = perf_meas)
}
```

### 

Another (perhaps more debatable) counterexample of a parameter that does not need to be tuned is the number of trees in a random forest or bagging model. This value should instead be chosen to be large enough to ensure numerical stability in the results; tuning it cannot improve performance as long as the value is large enough to produce reliable results.

### Exercise 26

Copy the previous code and continue the pipe to `collect_metrics()`. Inside `collect_metrics()`, set `summarize` to `FALSE`.

```{r what-do-we-optimize-26, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r what-do-we-optimize-26-hint-1, eval = FALSE}
function(...) {
  perf_meas <- metric_set(roc_auc, mn_log_loss)
    
  logistic_reg() |> 
    set_engine("glm", ...) |>
    fit_resamples(Class ~ A + B, rs, metrics = perf_meas) |>
    collect_metrics(summarize = ...)
}
```

```{r include = FALSE}
function(...) {
  perf_meas <- metric_set(roc_auc, mn_log_loss)
    
  logistic_reg() |> 
    set_engine("glm", ...) |>
    fit_resamples(Class ~ A + B, rs, metrics = perf_meas) |>
    collect_metrics(summarize = FALSE)
}
```

### 

As a reminder, `collect_metrics()` and `fit_resamples()` were introduced in the "Resampling for Evaluating Performance" tutorial, which is associated with [Chapter 10 of *Tidy Modeling with R*](https://www.tmwr.org/resampling).

### Exercise 27

Copy the previous code and continue the pipe to `select()`. Inside `select()`, type in `id`, `id2`, `.metric`, and `.estimate`.

```{r what-do-we-optimize-27, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r what-do-we-optimize-27-hint-1, eval = FALSE}
function(...) {
  perf_meas <- metric_set(roc_auc, mn_log_loss)
    
  logistic_reg() |> 
    set_engine("glm", ...) |>
    fit_resamples(Class ~ A + B, rs, metrics = perf_meas) |>
    collect_metrics(summarize = FALSE) |>
    select(..., ..., .metric, .estimate)
}
```

```{r include = FALSE}
function(...) {
  perf_meas <- metric_set(roc_auc, mn_log_loss)
    
  logistic_reg() |> 
    set_engine("glm", ...) |>
    fit_resamples(Class ~ A + B, rs, metrics = perf_meas) |>
    collect_metrics(summarize = FALSE) |>
    select(id, id2, .metric, .estimate)
}
```

### 

For random forests, the number of trees in a random forest or bagging mode is typically in the thousands while the number of trees needed for bagging is around 50 to 100.

### Exercise 28

Copy the previous code and assign the entire function to a new variable named `lloss`.

```{r what-do-we-optimize-28, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r what-do-we-optimize-28-hint-1, eval = FALSE}
... <- function(...) {
  perf_meas <- metric_set(roc_auc, mn_log_loss)
    
  logistic_reg() |> 
    set_engine("glm", ...) |>
    fit_resamples(Class ~ A + B, rs, metrics = perf_meas) |>
    collect_metrics(summarize = FALSE) |>
    select(id, id2, .metric, .estimate)
}
```

```{r include = FALSE}
lloss <- function(...) {
  perf_meas <- metric_set(roc_auc, mn_log_loss)
    
  logistic_reg() |> 
    set_engine("glm", ...) |>
    fit_resamples(Class ~ A + B, rs, metrics = perf_meas) |>
    collect_metrics(summarize = FALSE) |>
    select(id, id2, .metric, .estimate)
}
```

### 

The purpose of this function is to return the individual resampled performance estimates.

### Exercise 29

Now, lets bind some rows. Type in `bind_rows()`. Set the first argument of this function to `lloss()`, which is piped to `mutate(model = "logistic")` (Note: view the hint if you are confused).

```{r what-do-we-optimize-29, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r what-do-we-optimize-29-hint-1, eval = FALSE}
bind_rows(
  lloss() |> mutate(... = "...")
)
```

```{r include = FALSE}
bind_rows(
  lloss() |> mutate(model = "logistic")
)
```

### 

What this line of code is doing is it's calling `lloss()`, which has the individual resampled performance estimate and is creating a new column named `model`, which is set to `logistic`. This creation of the column was done by the `mutate()` function.

### Exercise 30

Copy the previous code. Set the second argument of `bind_rows()` to `lloss(family = binomial(link = "probit"))`, which is piped to `mutate(model = "probit")` (Note: view the hint if you are confused).

```{r what-do-we-optimize-30, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r what-do-we-optimize-30-hint-1, eval = FALSE}
bind_rows(
  lloss() |> mutate(model = "logistic"),
  lloss(... = binomial(link = "...")) |> mutate(model = "...")
)
```

```{r include = FALSE}
bind_rows(
  lloss() |> mutate(model = "logistic"),
  lloss(family = binomial(link = "probit")) |> mutate(model = "probit")
)
```

### 

This code has now binded the `probit` models to the tibble containing `logistic` models.

### Exercise 31

Copy the previous code. Set the third argument of `bind_rows()` to `lloss(family = binomial(link = "cloglog"))`, which is piped to `mutate(model = "c-log-log")` (Note: view the hint if you are confused).

```{r what-do-we-optimize-31, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r what-do-we-optimize-31-hint-1, eval = FALSE}
bind_rows(
  lloss() |> mutate(model = "logistic"),
  lloss(family = binomial(link = "probit")) |> mutate(model = "probit"),
  lloss(... = binomial(link = "...")) |> mutate(... = "...")
)
```

```{r include = FALSE}
bind_rows(
  lloss() |> mutate(model = "logistic"),
  lloss(family = binomial(link = "probit")) |> mutate(model = "probit"),
  lloss(family = binomial(link = "cloglog")) |> mutate(model = "c-log-log")
)
```

### 

This code binded the `cloglog` models to the tibble containing `probit` and `logistic` models.

### Exercise 32

Copy the previous code. Pipe the entire `bind_rows()` function to `mutate()`. 

```{r what-do-we-optimize-32, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r what-do-we-optimize-32-hint-1, eval = FALSE}
bind_rows(
  lloss() |> mutate(model = "logistic"),
  lloss(family = binomial(link = "probit")) |> mutate(model = "probit"),
  lloss(family = binomial(link = "cloglog")) |> mutate(model = "c-log-log")
) |>
  ...()
```

```{r include = FALSE}
bind_rows(
  lloss() |> mutate(model = "logistic"),
  lloss(family = binomial(link = "probit")) |> mutate(model = "probit"),
  lloss(family = binomial(link = "cloglog")) |> mutate(model = "c-log-log")
) |>
  mutate()
```

### 

### Exercise 33

Now, lets start converting `log-loss` to `log-likelihood`. Copy the previous code. Inside `mutate()`, set `.estimate` to `ifelse(.metric == "mn_log_loss", -.estimate, .estimate)`.

```{r what-do-we-optimize-33, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r what-do-we-optimize-33-hint-1, eval = FALSE}
bind_rows(
  lloss() |> mutate(model = "logistic"),
  lloss(family = binomial(link = "probit")) |> mutate(model = "probit"),
  lloss(family = binomial(link = "cloglog")) |> mutate(model = "c-log-log")
) |>
  mutate(.estimate = ...(.metric == "...", -.estimate, .estimate))
```

```{r include = FALSE}
bind_rows(
  lloss() |> mutate(model = "logistic"),
  lloss(family = binomial(link = "probit")) |> mutate(model = "probit"),
  lloss(family = binomial(link = "cloglog")) |> mutate(model = "c-log-log")
) |>
  mutate(.estimate = ifelse(.metric == "mn_log_loss", -.estimate, .estimate))
```

### 

This code modifies the `.estimate` column: If `.metric` is equal to `mn_log_loss`, negate that value in `.estimate`. If not, then keep it unchanged.

### Exercise 34

Copy the previous code and pipe it to `group_by()`. Inside this function, type in `model` and `.metric`. 

```{r what-do-we-optimize-34, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r what-do-we-optimize-34-hint-1, eval = FALSE}
bind_rows(
  lloss() |> mutate(model = "logistic"),
  lloss(family = binomial(link = "probit")) |> mutate(model = "probit"),
  lloss(family = binomial(link = "cloglog")) |> mutate(model = "c-log-log")
) |>
  mutate(.estimate = ifelse(.metric == "mn_log_loss", -.estimate, .estimate)) |>
  group_by(..., ....)
```

```{r include = FALSE}
bind_rows(
  lloss() |> mutate(model = "logistic"),
  lloss(family = binomial(link = "probit")) |> mutate(model = "probit"),
  lloss(family = binomial(link = "cloglog")) |> mutate(model = "c-log-log")
) |>
  mutate(.estimate = ifelse(.metric == "mn_log_loss", -.estimate, .estimate)) |>
  group_by(model, .metric)
```

### 

In this scanario, the `group_by()` function is grouping the data based on the `model` and `.metric`.

### Exercise 35

Copy the previous code and pipe it to `summarize()`. Inside of this function, set `.groups` to `"drop"`. 

```{r what-do-we-optimize-35, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r what-do-we-optimize-35-hint-1, eval = FALSE}
bind_rows(
  lloss() |> mutate(model = "logistic"),
  lloss(family = binomial(link = "probit")) |> mutate(model = "probit"),
  lloss(family = binomial(link = "cloglog")) |> mutate(model = "c-log-log")
) |>
  mutate(.estimate = ifelse(.metric == "mn_log_loss", -.estimate, .estimate)) |>
  group_by(model, .metric) |>
  summarize(
    .groups = "..."
  )
```

```{r include = FALSE, warning = FALSE}
bind_rows(
  lloss() |> mutate(model = "logistic"),
  lloss(family = binomial(link = "probit")) |> mutate(model = "probit"),
  lloss(family = binomial(link = "cloglog")) |> mutate(model = "c-log-log")
) |>
  mutate(.estimate = ifelse(.metric == "mn_log_loss", -.estimate, .estimate)) |>
  group_by(model, .metric) |>
  summarize(
    .groups = "drop"
  )
```

### 

<!-- AK: Getting a warning here and don't understand what it means: -->

<!-- A | warning: glm.fit: fitted probabilities numerically 0 or 1 occurred -->
<!-- There were issues with some computations   A: x3 -->

<!-- # A tibble: 6 × 4 -->
<!--   model     .metric       mean std_err -->
<!--   <chr>     <chr>        <dbl>   <dbl> -->
<!-- 1 c-log-log mn_log_loss -0.476 0.0117  -->
<!-- 2 c-log-log roc_auc      0.883 0.00472 -->
<!-- 3 logistic  mn_log_loss -0.443 0.00845 -->
<!-- 4 logistic  roc_auc      0.882 0.00471 -->
<!-- 5 probit    mn_log_loss -0.450 0.00850 -->
<!-- 6 probit    roc_auc      0.882 0.00471 -->

### Exercise 36

Copy the previous code. Inside `summarize()`, set `mean` to `mean(.estimate, na.rm = TRUE)`.

```{r what-do-we-optimize-36, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r what-do-we-optimize-36-hint-1, eval = FALSE}
bind_rows(
  lloss() |> mutate(model = "logistic"),
  lloss(family = binomial(link = "probit")) |> mutate(model = "probit"),
  lloss(family = binomial(link = "cloglog")) |> mutate(model = "c-log-log")
) |>
  mutate(.estimate = ifelse(.metric == "mn_log_loss", -.estimate, .estimate)) |>
  group_by(model, .metric) |>
  summarize(
    .groups = "drop",
    ... = mean(..., na.rm = TRUE)
  )
```

```{r include = FALSE}
bind_rows(
  lloss() |> mutate(model = "logistic"),
  lloss(family = binomial(link = "probit")) |> mutate(model = "probit"),
  lloss(family = binomial(link = "cloglog")) |> mutate(model = "c-log-log")
) |>
  mutate(.estimate = ifelse(.metric == "mn_log_loss", -.estimate, .estimate)) |>
  group_by(model, .metric) |>
  summarize(
    .groups = "drop",
    mean = mean(.estimate, na.rm = TRUE)
  )
```

### 

The `na.rm = TRUE` argument is used to ignore any missing values and perform calcuations on the non-missing values.

### Exercise 37

Copy the previous code. Inside `summarize()`, set `std_err` to `sd(.estimate, na.rm = TRUE) / sqrt(n())`

```{r what-do-we-optimize-37, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r what-do-we-optimize-37-hint-1, eval = FALSE}
bind_rows(
  lloss() |> mutate(model = "logistic"),
  lloss(family = binomial(link = "probit")) |> mutate(model = "probit"),
  lloss(family = binomial(link = "cloglog")) |> mutate(model = "c-log-log")
) |>
  mutate(.estimate = ifelse(.metric == "mn_log_loss", -.estimate, .estimate)) |>
  group_by(model, .metric) |>
  summarize(
    .groups = "drop",
    mean = mean(.estimate, na.rm = TRUE),
    std_err = sd(.estimate, na.rm = TRUE) / sqrt(n())
  )
```

```{r include = FALSE}
bind_rows(
  lloss() |> mutate(model = "logistic"),
  lloss(family = binomial(link = "probit")) |> mutate(model = "probit"),
  lloss(family = binomial(link = "cloglog")) |> mutate(model = "c-log-log")
) |>
  mutate(.estimate = ifelse(.metric == "mn_log_loss", -.estimate, .estimate)) |>
  group_by(model, .metric) |>
  summarize(
    .groups = "drop",
    mean = mean(.estimate, na.rm = TRUE),
    std_err = sd(.estimate, na.rm = TRUE) / sqrt(n())
  )
```

### 

The `sd()` function is being used here to calculate the standard deviation of the values inside the `.estimate` column. To calculate the standard error, this function is being divided by the square root of `n()`.

### Exercise 38

Copy the previous code and assign it to a new variable named `resampled_res`.

```{r what-do-we-optimize-38, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r what-do-we-optimize-38-hint-1, eval = FALSE}
... <- bind_rows(
  lloss() |> mutate(model = "logistic"),
  lloss(family = binomial(link = "probit")) |> mutate(model = "probit"),
  lloss(family = binomial(link = "cloglog")) |> mutate(model = "c-log-log")
) |>
  mutate(.estimate = ifelse(.metric == "mn_log_loss", -.estimate, .estimate)) |>
  group_by(model, .metric) |>
  summarize(
    .groups = "drop",
    mean = mean(.estimate, na.rm = TRUE),
    std_err = sd(.estimate, na.rm = TRUE) / sqrt(n())
  )
```

```{r include = FALSE, warning = FALSE}
resampled_res <- bind_rows(
  lloss() |> mutate(model = "logistic"),
  lloss(family = binomial(link = "probit")) |> mutate(model = "probit"),
  lloss(family = binomial(link = "cloglog")) |> mutate(model = "c-log-log")
) |>
  mutate(.estimate = ifelse(.metric == "mn_log_loss", -.estimate, .estimate)) |>
  group_by(model, .metric) |>
  summarize(
    .groups = "drop",
    mean = mean(.estimate, na.rm = TRUE),
    std_err = sd(.estimate, na.rm = TRUE) / sqrt(n())
  )
```

### 

This code has successfully resampled the results of the 10-fold-cross-validation.

### Exercise 39

Now, lets plot this data on a graph. But first, a filtration must occur. In the code chunk below, pipe `resampled_res` to `filter()`. Inside this function, type in the expression `.metric == "mn_log_loss"`.

```{r what-do-we-optimize-39, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r what-do-we-optimize-39-hint-1, eval = FALSE}
resampled_res |>
  ...(.metric == "...")
```

```{r include = FALSE}
resampled_res |> 
  filter(.metric == "mn_log_loss")
```

### 

This code is filtering the data, making sure that the only `mn_log_loss` data is present.

### Exercise 40

Copy the previous code and pipe it to `ggplot()`. Inside this function, using `aes()`, set the argument `x` to `mean` and `y` to `model`.

```{r what-do-we-optimize-40, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r what-do-we-optimize-40-hint-1, eval = FALSE}
resampled_res |> 
  filter(.metric == "mn_log_loss") |>
  ggplot(aes(x = ..., y = ...))
```

```{r include = FALSE}
resampled_res |> 
  filter(.metric == "mn_log_loss") |>
  ggplot(aes(x = mean, y = model))
```

### 

If you are unfamiliar with the term "model tuning", model tuning refers to the process of adjusting the hyperparameters of a model in order to optimize its performance.

### Exercise 41

Copy the previous code and add `geom_point()`.

```{r what-do-we-optimize-41, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r what-do-we-optimize-41-hint-1, eval = FALSE}
resampled_res |> 
  filter(.metric == "mn_log_loss") |>
  ggplot(aes(x = mean, y = model)) +
  ...()
```

```{r include = FALSE}
resampled_res |> 
  filter(.metric == "mn_log_loss") |>
  ggplot(aes(x = mean, y = model)) +
  geom_point()
```

### 

As you can see, this produces three points on the graph. Using these points, the 90& confidence intervals can be created using `geom_errorbar()`.

### Exercise 42

Copy the previous code and add `geom_errorbar()`. Inside this function, using `aes()`, set `xmin` to `mean - 1.64 * std_err` (Note: This will throw an error).

```{r what-do-we-optimize-42, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r what-do-we-optimize-42-hint-1, eval = FALSE}
resampled_res |> 
  filter(.metric == "mn_log_loss") |>
  ggplot(aes(x = mean, y = model)) +
  geom_point() +
  geom_errorbar(...(... = mean - 1.64 * std_err))
```

```{r include = FALSE}
#resampled_res |> 
#  filter(.metric == "mn_log_loss") |>
#  ggplot(aes(x = mean, y = model)) +
#  geom_point() +
#  geom_errorbar(aes(xmin = mean - 1.64 * std_err))
```

### 

This code throws an error because the `xmax` hasn't been defined yet.

### Exercise 43

Copy the previous code. Inside the `aes()` function inside of `geom_errorbar()`, set `xmax` to `mean + 1.64 * std_err`. 

```{r what-do-we-optimize-43, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r what-do-we-optimize-43-hint-1, eval = FALSE}
resampled_res |> 
  filter(.metric == "mn_log_loss") |>
  ggplot(aes(x = mean, y = model)) +
  geom_point() +
  geom_errorbar(aes(xmin = mean - 1.64 * std_err, ... = mean + 1.64 * std_err))
```

```{r include = FALSE}
resampled_res |> 
  filter(.metric == "mn_log_loss") |>
  ggplot(aes(x = mean, y = model)) +
  geom_point() +
  geom_errorbar(aes(xmin = mean - 1.64 * std_err, xmax = mean + 1.64 * std_err))
```

### 

As you can see, each point now has a line on the right and left side, which represents the confidence intervals. 

### Exercise 44

Copy the previous code. Inside the `aes()` function inside of `geom_errorbar()`, set the `width` to `0.1`.

```{r what-do-we-optimize-44, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r what-do-we-optimize-44-hint-1, eval = FALSE}
resampled_res |> 
  filter(.metric == "mn_log_loss") |>
  ggplot(aes(x = mean, y = model)) +
  geom_point() +
  geom_errorbar(aes(xmin = mean - 1.64 * std_err, xmax = mean + 1.64 * std_err, width = ...))
```

```{r include = FALSE}
resampled_res |> 
  filter(.metric == "mn_log_loss") |>
  ggplot(aes(x = mean, y = model)) +
  geom_point() +
  geom_errorbar(aes(xmin = mean - 1.64 * std_err, xmax = mean + 1.64 * std_err, width = 0.1))
```

### 

The scale of these values is different than the previous values since they are computed on a smaller data set; the value produced by `broom::glance()` is a sum while `yardstick::mn_log_loss()` is an average.

### Exercise 45

Copy the previous code and add your labs. The final plot should look like this:

```{r}
logLikelihoodPlot
```

```{r what-do-we-optimize-45, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r what-do-we-optimize-45-hint-1, eval = FALSE}
resampled_res |> 
  filter(.metric == "mn_log_loss") |>
  ggplot(aes(x = mean, y = model)) +
  geom_point() +
  geom_errorbar(aes(xmin = mean - 1.64 * std_err, xmax = mean + 1.64 * std_err, width = 0.1)) +
  labs(
    x = "...",
    ... = NULL
  )
```

```{r include = FALSE}
resampled_res |> 
  filter(.metric == "mn_log_loss") |>
  ggplot(aes(x = mean, y = model)) +
  geom_point() +
  geom_errorbar(aes(xmin = mean - 1.64 * std_err, xmax = mean + 1.64 * std_err, width = 0.1)) +
  labs(
    x = "log-likelihood",
    y = NULL
  )
```

### 

These results exhibit evidence that the choice of the link function matters somewhat. Although there is an overlap in the confidence intervals, the logistic model has the best results.

### Exercise 46

What about a different metric? The area under the ROC curve for each resample was also calcuated. These results, which reflect the discriminative ability of the models across numerous probability thresholds, show a lack of difference 

```{r}
knitr::include_graphics("images/pic2.png")
```

### 

Given the overlap of the intervals, as well as the scale of the x-axis, any of these options could be used.

### Exercise 47

When the class boundaries for the three models are overlaid on the test set of 198 data points as shown in the image below, this is seen again:

```{r}
knitr::include_graphics("images/pic3.png")
```

### 

This exercise emphasizes that different metrics might lead to different decisions about the choice of tuning parameter values. In this case, one metric indicates the models are somewhat different while another metric shows no difference at all.

###

Congrats! You have learned how to evaluate models when optimizing tuning parameters.

## Tuning Parameters in Tidymodels
###

You have already dealt with quite a number of arguments that correspond to tuning parameters for recipe and model specifications in previous chapters. It is possible to tune:

- the threshold for combining neighborhoods into an “other” category (with argument name `threshold`)

- the number of degrees of freedom in a natural spline (`deg_free`)

- the number of data points required to execute a split in a tree-based model (`min_n`)

- the amount of regularization in penalized models (`penalty`)

### Exercise 1

The `rand_forest()` function contains a series of arguments that can be passed in. Type `?rand_forest()` in the Console and look at the *Arguments* section. CP/CR.

```{r tuning-parameters-in-1}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

###

For **parsnip** model specifications, there are two kinds of parameter arguments. Main arguments are those that are most often optimized for performance and are available in multiple engines. The main tuning parameters are top-level arguments to the model specification function. For example, the `rand_forest()` function has *main* arguments `trees`, `min_n`, and `mtry` since these are most frequently specified or optimized.

### Exercise 2

A secondary set of tuning parameters are *engine specific*. These are either infrequently optimized or are specific only to certain engines. Again using random forests as an example, the **ranger** package contains some arguments that are not used by other packages.

Type `?set_engine()` in the Console and look at the *Arguments* section. CP/CR.

```{r tuning-parameters-in-2}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

###

One example is gain penalization, which regularizes the predictor selection in the tree induction process. This parameter can help modulate the trade-off between the number of predictors used in the ensemble and performance. The name of this argument in **ranger** is `regularization.factor`.

### Exercise 3

Now, lets specify a value via a **parsnip** model specification. In the code chunk below, type in `rand_forest()`.

```{r tuning-parameters-in-3, exercise = TRUE}

```

```{r tuning-parameters-in-3-hint, eval = FALSE}
...()
```

```{r, include = FALSE}
rand_forest()
```

###

Many tuning parameters modulate the amount of model complexity. More complexity often implies more malleability in the patterns that a model can emulate. For example, adding degrees of freedom in a spline function increases the intricacy of the prediction equation. While this is an advantage when the underlying motifs in the data are complex, it can also lead to overinterpretation of chance patterns that would not reproduce in new data. 

### Exercise 4

Copy the previous code. Inside the function, set `trees` to `2000`

```{r tuning-parameters-in-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r tuning-parameters-in-4-hint, eval = FALSE}
rand_forest(... = 2000)
```

```{r, include = FALSE}
rand_forest(trees = 2000)
```

###

Overfitting is the situation where a model adapts too much to the training data; it performs well for the data used to build the model but poorly for new data. Since tuning model parameters can increase model complexity, poor choices can lead to overfitting.

### Exercise 5

Copy the previous code. Inside `rand_forest()`, set `min_n` to `10`.

```{r tuning-parameters-in-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r tuning-parameters-in-5-hint, eval = FALSE}
rand_forest(trees = 2000, ... = 10)
```

```{r, include = FALSE}
rand_forest(trees = 2000, min_n = 10)
```

###

With a single hidden unit and sigmoidal activation functions, a neural network for classification is, for all intents and purposes, just logistic regression. However, as the number of hidden units increases, so does the complexity of the model. 

In fact, when the network model uses sigmoidal activation units, George Cybenko, the Dorothy and Walter Gramm Professor of Engineering at Dartmouth, showed that the model is a universal function approximator as long as there are enough hidden units.

### Exercise 6

Copy the previous code and pipe it to `set_engine()`. Inside this function, type in `"ranger"` and set `regularization.factor` to `0.5`.

```{r tuning-parameters-in-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r tuning-parameters-in-6-hint, eval = FALSE}
rand_forest(trees = 2000, min_n = 10) |>
  set_engine("...", regularization.factor = ...
```

```{r, include = FALSE}
rand_forest(trees = 2000, min_n = 10) |>
  set_engine("ranger", regularization.factor = 0.5)  
```

###

The main arguments use a harmonized naming system to remove inconsistencies across engines while engine-specific arguments do not.

### Exercise 7

How can you signal to tidymodels functions which arguments should be optimized? Parameters are marked for tuning by assigning them a value of `tune()`. Lets do just that.

In the code chunk below, type in `mlp()`. Inside this function, set the `hidden_units` argument to `tune()`.

```{r tuning-parameters-in-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r tuning-parameters-in-7-hint, eval = FALSE}
mlp(... = tune())
```

```{r, include = FALSE}
mlp(hidden_units = tune())
```

###

We fit neural network classification models to the same two-class data from the previous section, varying the number of hidden units. Using the area under the ROC curve as a performance metric, the effectiveness of the model on the training set increases as more hidden units are added. 

The network model thoroughly and meticulously learns the training set. If the model judges itself on the training set ROC value, it prefers many hidden units so that it can nearly eliminate errors.

### Exercise 8

Copy the previous code and pipe it to `set_mode()`. Inside this function, type in `"regression"`.

```{r tuning-parameters-in-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r tuning-parameters-in-8-hint, eval = FALSE}
mlp(hidden_units = tune()) |>
  set_mode("...")
```

```{r, include = FALSE}
mlp(hidden_units = tune()) |>
  set_mode("regression")
```

###

[Chapters 5](https://www.tmwr.org/splitting#splitting) and [10](https://www.tmwr.org/resampling#resampling) in the [*Tidy Modeling with R*](https://www.tmwr.org/index.html) textbook demonstrated that simply repredicting the training set is a poor approach to model evaluation. Here, the neural network very quickly begins to overinterpret patterns that it sees in the training set. Compare these three example class boundaries (developed with the training set) overlaid on training and test sets in the image below:

```{r}
knitr::include_graphics("images/pic4.png")
```


### Exercise 9

Copy the previous code and pipe it to `set_engine()`. Inside this function, type in `"keras"`.

```{r tuning-parameters-in-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r tuning-parameters-in-9-hint, eval = FALSE}
mlp(hidden_units = tune()) |>
  set_mode("regression") |>
  set_engine("...")
```

```{r, include = FALSE}
mlp(hidden_units = tune()) |>
  set_mode("regression") |>
  set_engine("keras")
```

###

As you can see from the graph in the previous exercise, the single unit model does not adapt very flexibly to the data (since it is constrained to be linear). A model with four hidden units begins to show signs of overfitting with an unrealistic boundary for values away from the data mainstream. This is caused by a single data point from the first class in the upper-right corner of the data. 

### Exercise 10

Copy the previous code and assign it to a new variable called `neural_net_spec`.

```{r tuning-parameters-in-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r tuning-parameters-in-10-hint, eval = FALSE}
... <- 
  mlp(hidden_units = tune()) |>
  set_mode("regression") |>
  set_engine("keras")
```

```{r, include = FALSE}
neural_net_spec <- 
  mlp(hidden_units = tune()) |>
  set_mode("regression") |>
  set_engine("keras")
```

###

By 20 hidden units, the model (from the graph) is beginning to memorize the training set, creating small islands around those data to minimize the resubstitution error rate. These patterns do not repeat in the test set. This last panel is the best illustration of how tuning parameters that control complexity must be modulated so that the model is effective. For a 20-unit model, the training set ROC AUC is 0.944 but the test set value is 0.855.

### Exercise 11

The tune() function doesn’t actually execute any particular parameter value; it only returns an expression. In the code chunk below, type in `tune()` and press "Run Code".

```{r tuning-parameters-in-11, exercise = TRUE}

```

```{r tuning-parameters-in-11-hint, eval = FALSE}
...()
```

```{r, include = FALSE}
tune()
```

###

Embedding this `tune()` value in an argument will tag the parameter for optimization. The model tuning functions shown in the next two chapters parse the model specification and/or recipe to discover the tagged parameters. These functions can automatically configure and process these parameters since they understand their characteristics (e.g., the range of possible values, etc.).

### Exercise 12

To enumerate the tuning parameters for an object, the `extract_parameter_set_dials()` will be used. In the code chunk below, type in `extract_parameter_set_dials()`, passing in `neural_net_spec`.

```{r tuning-parameters-in-12, exercise = TRUE}

```

```{r tuning-parameters-in-12-hint, eval = FALSE}
extract_parameter_set_dials(...)
```

```{r, include = FALSE}
extract_parameter_set_dials(neural_net_spec)
```

###

The results show a value of `nparam[+]`, indicating that the number of hidden units is a numeric parameter.

### Exercise 13



```{r tuning-parameters-in-13, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r tuning-parameters-in-13-hint, eval = FALSE}

```

```{r, include = FALSE}

```

###

(maybe keep here) The occurrence of overfitting from the graph in the previous exercises is obvious with two predictors that can be plotted. However, in general, a quantitative approach must be used for detecting overfitting.

The solution for detecting when a model is overemphasizing the training set is using out-of-sample data.
 

## Summary
### 

<!-- Two to four sentences which bring the lessons of the tutorial together for the student. What do they know now that they did not know before? How does this tutorial connect to other tutorials? OK if this is very similar to the Introduction. You made a promise as to what they would learn. You (we hope!) kept that promise.-->

```{r download-answers, child = system.file("child_documents/download_answers.Rmd", package = "tutorial.helpers")}
```
