---
title: Grid Search
author: Pratham Kancherla
tutorial:
  id: grid-search
output: 
  learnr::tutorial:
    progressive: yes
    allow_skip: yes
runtime: shiny_prerendered
description: 'Tutorial for Chapter 13: Grid Search'
---

```{r setup, include = FALSE}
library(learnr)
library(tutorial.helpers)
library(knitr)
library(tidyverse)
library(tidymodels)
library(tune)
library(ggrepel)
library(ggforce)
library(rstanarm)
library(tidyposterior)
library(lme4)
library(multilevelmod)
library(nlme)
library(workflowsets)

tidymodels_prefer()

knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 60, 
        tutorial.storage = "local") 

mlp_spec <- 
  mlp(hidden_units = tune(), penalty = tune(), epochs = tune()) |>
  set_engine("nnet", trace = 0) |> 
  set_mode("classification")

mlp_param <- extract_parameter_set_dials(mlp_spec)
```

```{r copy-code-chunk, child = system.file("child_documents/copy_button.Rmd", package = "tutorial.helpers")}
```

```{r info-section, child = system.file("child_documents/info_section.Rmd", package = "tutorial.helpers")}
```


## Introduction
###

<!-- Two to four sentence about the main topics covered in this tutorial. Why are we here? What will students get out of giving you 90 minutes of their lives? How does this tutorial connect to other tutorials? -->

## Regular and Non-Regular Grids
###

There are two main types of grids. A regular grid combines each parameter (with its corresponding set of possible values) factorially, i.e., by using all combinations of the sets. Alternatively, a nonregular grid is one where the parameter combinations are not formed from a small set of points.

### Exercise 1

"MLP" stands for Multi-Layer Perceptron, which is a type of artificial neural network. MLPs are a class of feedforward neural networks that consist of multiple layers of interconnected nodes (neurons). They are commonly used for various machine learning tasks, including classification and regression.

Type `mlp()` and hit "Run Code".

```{r regular-and-nonregul-1, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r regular-and-nonregul-1-hint, eval = FALSE}
mlp()
```

```{r, include = FALSE}
mlp()
```

###

This produces the output of a single layer neural network model specification with the computational engine of **nnet**.

### Exercise 2

Copy the previous code and add the parameter `hidden_units`, setting it equal to `tune()`.

```{r regular-and-nonregul-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r regular-and-nonregul-2-hint, eval = FALSE}
mlp(hidden_units = ...())
```

```{r, include = FALSE}
mlp(hidden_units = tune())
```

###

In R, the `tune()` function is typically used in conjunction with the **caret** package to perform hyperparameter tuning for machine learning models.

### Exercise 3

Copy the previous code add the parameters `penalty` and `epochs`, setting them both equal to `tune()`.

```{r regular-and-nonregul-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r regular-and-nonregul-3-hint, eval = FALSE}
mlp(hidden_units = tune(), ... = tune(), epochs = ...())
```

```{r, include = FALSE}
mlp(hidden_units = tune(), penalty = tune(), epochs = tune())
```

###

`penalty`	is a non-negative numeric value for the amount of weight decay and `epochs` is an integer for the number of training iterations.

### Exercise 4

Copy the previous code and pipe it to `set_engine()`. Add the parameters `"nnet"` and `trace = 0`. 

```{r regular-and-nonregul-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r regular-and-nonregul-4-hint, eval = FALSE}
... |>
  set_engine("...", trace = ...)
```

```{r, include = FALSE}
 mlp(hidden_units = tune(), penalty = tune(), epochs = tune()) |> 
  set_engine("nnet", trace = 0)
```

###

Now the main arguments and Engine-Specific Arguments have been set. All that needs to be done is add the model.

### Exercise 5

Copy the previous code and pipe it to `set_mode()`. Add the parameter `"classification"`. Then, set the entire expression to `mlp_spec` using `<-`.

```{r regular-and-nonregul-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r regular-and-nonregul-5-hint, eval = FALSE}
mlp_sec <-
  ... |>
  set_mode("...")
```

```{r, include = FALSE}
mlp_spec <- 
  mlp(hidden_units = tune(), penalty = tune(), epochs = tune()) |>
  set_engine("nnet", trace = 0) |> 
  set_mode("classification")
```

###

The argument `trace = 0` prevents extra logging of the training process. The `extract_parameter_set_dials()` function can extract the set of arguments with unknown values and sets their **dials** objects.

### Exercise 6

Set `mlp_param` to the expression `extract_parameter_set_dials(mlp_spec)` using `<-`.

```{r regular-and-nonregul-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r regular-and-nonregul-6-hint, eval = FALSE}
mlp_param <- ...(mlp_spec)
```

```{r, include = FALSE}
mlp_param <- extract_parameter_set_dials(mlp_spec)
```

###

`extract_parameter_set_dials()` returns a set of dials parameter objects. Many models contain tuning parameters (i.e. parameters that cannot be directly estimated from the data). These tools can be used to define objects for creating, simulating, or validating values for such parameters.

### Exercise 7

Now pipe `mlp_param` to `extract_parameter_dials()`. Add the parameter `"hidden_units"` and hit "Run Code".

```{r regular-and-nonregul-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r regular-and-nonregul-7-hint, eval = FALSE}
mlp_param |>
  extract_parameter_dials("...")
```

```{r, include = FALSE}
mlp_param |>
  extract_parameter_dials("hidden_units")
```

###

<!-- PK: Knowledge Drop -->

### Exercise 8

Copy the previous exercise and switch `"hidden_units"` to `"penalty"`.

```{r regular-and-nonregul-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r regular-and-nonregul-8-hint, eval = FALSE}
mlp_param |>
  extract_parameter_dials("...")
```

```{r, include = FALSE}
mlp_param |>
  extract_parameter_dials("penalty")
```

###

<!-- PK: Knowledge Drop -->

### Exercise 9

Copy the previous code and switch `"penalty"` to `"epochs"`.

```{r regular-and-nonregul-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r regular-and-nonregul-9-hint, eval = FALSE}
mlp_param %>% extract_parameter_dials("...")
```

```{r, include = FALSE}
mlp_param |>
  extract_parameter_dials("epochs")
```

###

Regular grids are combinations of separate sets of parameter values. The number of possible values need not be the same for each parameter. The **tidyr** function `crossing()` is one way to create a regular grid.

### Exercise 10

Type `crossing()` and add the parameters `hidden_units = 1:3`, `penalty = c(0.0, 0.1)`, and `epochs = c(100, 200)`.

```{r regular-and-nonregul-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r regular-and-nonregul-10-hint, eval = FALSE}
crossing(... = 1:3,
         penalty = ...(0.0, 0.1),
         epochs = c(..., ...)
         )
```

```{r, include = FALSE}
crossing(hidden_units = 1:3,
         penalty = c(0.0, 0.1),
         epochs = c(100, 200)
         )
```

###

`grid_regular()` can create random and regular grids for any number of parameter objects. The parameter object knows the ranges of the parameters. The **dials** package contains a set of `grid_*()` functions that take the parameter object as input to produce different types of grids. 

### Exercise 11

Type `grid_regular()` and add the parameter `mlp_param`. 

```{r regular-and-nonregul-11, exercise = TRUE}

```

```{r regular-and-nonregul-11-hint, eval = FALSE}
grid_regular(...)
```

```{r, include = FALSE}
grid_regular(mlp_param)
```

###

The `levels` argument is the number of levels per parameter to create. It can also take a named vector of values.

### Exercise 12

Copy the previous code and add the parameter `levels`, setting it equal to 2.

```{r regular-and-nonregul-12, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r regular-and-nonregul-12-hint, eval = FALSE}
grid_regular(mlp_param, levels = ...)
```

```{r, include = FALSE}
grid_regular(mlp_param, levels = 2)
```

###

There are techniques for creating regular grids that do not use all possible values of each parameter set. These *fractional factorial designs* could also be used. To learn more, consult the CRAN Task View for experimental design.

### Exercise 13

Copy the previous code and switch the `levels` parameter to make it equal a vector of `hidden_units = 3`, `penalty = 2`, `epochs = 2`.

```{r regular-and-nonregul-13, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r regular-and-nonregul-13-hint, eval = FALSE}
grid_regular(mlp_param, levels = c(... = 3, penalty = 2, epochs = ...))
```

```{r, include = FALSE}
grid_regular(mlp_param, levels = c(hidden_units = 3, penalty = 2, epochs = 2))
```

###

Regular grids can be computationally expensive to use, especially when there are a medium-to-large number of tuning parameters. This is true for many models but not all. 

### Exercise 14

The `grid_random()` function generates independent uniform random numbers across the parameter ranges. 

Type `grid_random()` and add the parameters `mlp_param` and `size = 1000`.

```{r regular-and-nonregul-14, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r regular-and-nonregul-14-hint, eval = FALSE}
grid_random(mlp_param, size = ...)
```

```{r, include = FALSE}
grid_random(mlp_param, size = 1000)
```

###

There are several options for creating non-regular grids. The first is to use random sampling across the range of parameters.

### Exercise 15

To view the summary of the previous code, copy the previous code and pipe it to `summary()`.

```{r regular-and-nonregul-15, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r regular-and-nonregul-15-hint, eval = FALSE}
... |>
  ...()
```

```{r, include = FALSE}
grid_random(mlp_param, size = 1000) |>
  summary()
```

###

The issue with random grids is that, with small-to-medium grids, random values can result in overlapping parameter combinations. Also, the random grid needs to cover the whole parameter space, but the likelihood of good coverage increases with the number of grid values.

### Exercise 16

Now we will graoh the grid. Type `mlp_param` and pipe it to `grid_random()`, with the parameters `size = 20` and `original = FALSE`.

```{r regular-and-nonregul-16, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r regular-and-nonregul-16-hint, eval = FALSE}
mlp_param |>
  grid_random(... = 20, original = ...)
```

```{r, include = FALSE}
mlp_param |>
  grid_random(size = 20, original = FALSE)
```

###

If the parameter object has an associated transformation (such as we have for `penalty`), the random numbers are generated on the transformed scale.

### Exercise 17

Copy the previous code and pipe it to `ggplot()`. Within `aes()` of `ggplot()`, add the parameters `x = .panel_x` and `y = .panel_y`

```{r regular-and-nonregul-17, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r regular-and-nonregul-17-hint, eval = FALSE}

```

```{r, include = FALSE}
mlp_param |>
  grid_random(size = 20, original = FALSE) |>
  ggplot(aes(x = .panel_x, y = .panel_y))
```

###




## Summary
###

<!-- Two to four sentences which bring the lessons of the tutorial together for the student. What do they know now that they did not know before? How does this tutorial connect to other tutorials? OK if this is very similar to the Introduction. You made a promise as to what they would learn. You (we hope!) kept that promise.-->

```{r download-answers, child = system.file("child_documents/download_answers.Rmd", package = "tutorial.helpers")}
```
