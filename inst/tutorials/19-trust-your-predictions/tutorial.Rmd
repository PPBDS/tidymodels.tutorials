---
title: When Should you Trust Your Predictions?
author: Pratham Kancherla
tutorial:
  id: when-should-you-trust-your-predictions-?
output:
  learnr::tutorial:
    progressive: yes
    allow_skip: yes
runtime: shiny_prerendered
description: 'Tutorial for Chapter 19: When Should you Trust Your Predictions?'
---

```{r setup, include = FALSE}
library(learnr)
library(tutorial.helpers)
library(finetune)
library(baguette)
library(tidyverse)
library(tidymodels)
library(rlang)
library(embed)
library(tune)
library(ggrepel)
library(ggforce)
library(rstanarm)
library(rules)
library(tidyposterior)
library(lme4)
library(multilevelmod)
library(nlme)
library(usemodels)
library(workflowsets)
knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 60, 
        tutorial.storage = "local") 

simulate_two_classes <- 
  function (n, error = 0.1, eqn = quote(-1 - 2 * x - 0.2 * x^2 + 2 * y^2))  {
    sigma <- matrix(c(1, 0.7, 0.7, 1), nrow = 2, ncol = 2)
    dat <- MASS::mvrnorm(n = n, mu = c(0, 0), Sigma = sigma)
    colnames(dat) <- c("x", "y")
    cls <- paste0("class_", 1:2)
    dat <- 
      as_tibble(dat) %>% 
      mutate(
        linear_pred = !!eqn,
        linear_pred = linear_pred + rnorm(n, sd = error),
        prob = binomial()$linkinv(linear_pred),
        class = ifelse(prob > runif(n), cls[1], cls[2]),
        class = factor(class, levels = cls)
      )
    dplyr::select(dat, x, y, class)
  }

training_set <- simulate_two_classes(200)
testing_set <- simulate_two_classes(50)

two_class_mod <-
  logistic_reg() |>
  set_engine("stan") |>
  fit(class ~ . + I(x^2)+ I(y^2), data = training_set)

test_pred <- augment(two_class_mod, testing_set)

lvls <- levels(training_set$class)

test_pred1 <-
  test_pred |>
  mutate(.pred_with_eqz = make_two_class_pred(.pred_class_1, lvls, buffer = 0.15))
```

```{r copy-code-chunk, child = system.file("child_documents/copy_button.Rmd", package = "tutorial.helpers")}
```

```{r info-section, child = system.file("child_documents/info_section.Rmd", package = "tutorial.helpers")}
```

## Introduction
### 

<!-- Two to four sentence about the main topics covered in this tutorial. Why are we here? What will students get out of giving you 90 minutes of their lives? How does this tutorial connect to other tutorials? -->

## Equicoval Results
### 

In some cases, the amount of uncertainty associated with a prediction is too high to be trusted.

### Exercise 1

Load the library **tidymodels** using `library()`.

```{r equicoval-results-1, exercise = TRUE}

```

```{r equicoval-results-1-hint-1, eval = FALSE}
library(...)
```

```{r include = FALSE}
library(tidymodels)
```

### 

When a new data point is well outside of the range of data used to create the model, making a prediction may be an inappropriate *extrapolation*.

### Exercise 2

Now we will create a function of a training set of 200 samples and a test set of 50. Type `function()` and add the parameters `n`, `error`, setting it equal to `0.1`, and `eqn`, setting it equal to `quote(-1 - 2 * x - 0.2 * x^2 + 2 * y^2)`.

```{r equicoval-results-2, exercise = TRUE}

```

```{r equicoval-results-2-hint-1, eval = FALSE}
function (..., error = ..., eqn = quote(...))
```

```{r include = FALSE}
function (n, error = 0.1, eqn = quote(-1 - 2 * x - 0.2 * x^2 + 2 * y^2))
```

### 

In some cases, the amount of uncertainty associated with a prediction is too high to be trusted.

### Exercise 3

Copy the previous code and add two `{}` brackers. Within the brackets, type `matrix()` and add the parameters `c(1, 0.7, 0.7, 1)`, `nrow`, setting it equal to `2`, and `ncol`, setting it equal to `2`. Then, set the `matrix()` expression to `sigma`. (Check Hint for Formatting).

```{r equicoval-results-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r equicoval-results-3-hint-1, eval = FALSE}
function (n, error = 0.1, eqn = quote(-1 - 2 * x - 0.2 * x^2 + 2 * y^2)) {
  sigma <- matrix(c(...), nrow = ..., ncol = ...)
}
```

```{r include = FALSE}
function (n, error = 0.1, eqn = quote(-1 - 2 * x - 0.2 * x^2 + 2 * y^2))  {
  sigma <- matrix(c(1, 0.7, 0.7, 1), nrow = 2, ncol = 2)
}
```

### 

An equivocal zone is a range of results in which the prediction should not be reported to patients, for example, some range of COVID-19 test results that are too uncertain to be reported to a patient. 

### Exercise 4

Copy the previous code. On the next line, type `MASS::mvrnorm()`. Add the parameters `n`, setting it equal to `n`, `mu`, setting it equal to `c(0, 0)`, and `Sigma`, setting it equal to `sigma`. Set the `mvrnorm()` expression to `dat` using `<-`.

```{r equicoval-results-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r equicoval-results-4-hint-1, eval = FALSE}
function (n, error = 0.1, eqn = quote(-1 - 2 * x - 0.2 * x^2 + 2 * y^2))  {
  sigma <- matrix(c(1, 0.7, 0.7, 1), nrow = 2, ncol = 2)
  dat <- MASS::mvrnorm(n = ..., mu = c(..., 0), Sigma = ...)
}
```

```{r include = FALSE}
function (n, error = 0.1, eqn = quote(-1 - 2 * x - 0.2 * x^2 + 2 * y^2))  {
  sigma <- matrix(c(1, 0.7, 0.7, 1), nrow = 2, ncol = 2)
  dat <- MASS::mvrnorm(n = n, mu = c(0, 0), Sigma = sigma)
}
```

### 

An example of an inappropriate prediction when a model is used in a completely different context, such as applying a cell segmentation model regarding breast cancer cells to stomach cells and making a prediction.

### Exercise 5

Copy the previous code and type `c()`. Add the parameters `"x"` and `"y"`. Set the `c()` expression to `colnames(dat)`.

```{r equicoval-results-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r equicoval-results-5-hint-1, eval = FALSE}
function (n, error = 0.1, eqn = quote(-1 - 2 * x - 0.2 * x^2 + 2 * y^2))  {
  ...
  colnames(dat) <- c("...", "...")
}
```

```{r include = FALSE}
function (n, error = 0.1, eqn = quote(-1 - 2 * x - 0.2 * x^2 + 2 * y^2))  {
  sigma <- matrix(c(1, 0.7, 0.7, 1), nrow = 2, ncol = 2)
  dat <- MASS::mvrnorm(n = n, mu = c(0, 0), Sigma = sigma)
  colnames(dat) <- c("x", "y")
  cls <- paste0("class_", 1:2)
}
```

### 

In R, the **mvrnorm** function is part of the **MASS** package (Modern Applied Statistics with S) and is used to generate random samples from a multivariate normal distribution. 

### Exercise 6

Copy the previous code and, on the next line, type `paste0()`. Add the parameters `"class_"` and `1:2`. Set the `paste0` expression `cls` using `<-`. 

```{r equicoval-results-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r equicoval-results-6-hint-1, eval = FALSE}
function (n, error = 0.1, eqn = quote(-1 - 2 * x - 0.2 * x^2 + 2 * y^2))  {
  ...
  cls <- paste0("class_", 1:2)
}
```

```{r include = FALSE}
function (n, error = 0.1, eqn = quote(-1 - 2 * x - 0.2 * x^2 + 2 * y^2))  {
  sigma <- matrix(c(1, 0.7, 0.7, 1), nrow = 2, ncol = 2)
  dat <- MASS::mvrnorm(n = n, mu = c(0, 0), Sigma = sigma)
  colnames(dat) <- c("x", "y")
  cls <- paste0("class_", 1:2)
}
```

### 

**mvrnorm** parameters explained:
`n`: This is the number of random samples (observations) you want to generate from the multivariate normal distribution.

### Exercise 7

Copy the previous code and, on the next line, type `as_tibble()`, add the parameter `dat`. Then, pipe the function to `mutate()`. First, add the parameter `linear_pred`, setting it equal to `!!eqn`.

```{r equicoval-results-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r equicoval-results-7-hint-1, eval = FALSE}
function (n, error = 0.1, eqn = quote(-1 - 2 * x - 0.2 * x^2 + 2 * y^2))  {
  ...
  as_tibble(...) |>
    mutate(
      linear_pred = !!...
    )
}
```

```{r include = FALSE}
function (n, error = 0.1, eqn = quote(-1 - 2 * x - 0.2 * x^2 + 2 * y^2))  {
  sigma <- matrix(c(1, 0.7, 0.7, 1), nrow = 2, ncol = 2)
  dat <- MASS::mvrnorm(n = n, mu = c(0, 0), Sigma = sigma)
  colnames(dat) <- c("x", "y")
  cls <- paste0("class_", 1:2)
  as_tibble(dat) |>
    mutate(
      linear_pred = !!eqn
    )
}
```

### 

**mvrnorm** parameters explained:
`mu`: This is a numeric vector representing the mean of the multivariate normal distribution. It should have the same length as the number of variables you want to generate.

### Exercise 8

Copy the previous code and update `linear_pred` to `linear_pred + rnorm(n, sd = error)`.

```{r equicoval-results-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r equicoval-results-8-hint-1, eval = FALSE}
function (n, error = 0.1, eqn = quote(-1 - 2 * x - 0.2 * x^2 + 2 * y^2))  {
  ...
  as_tibble(dat) |>
    mutate(
      linear_pred = !!eqn,
      linear_pred = ... + rnorm(n, sd = ...)
    )
}
```

```{r include = FALSE}
function (n, error = 0.1, eqn = quote(-1 - 2 * x - 0.2 * x^2 + 2 * y^2))  {
  sigma <- matrix(c(1, 0.7, 0.7, 1), nrow = 2, ncol = 2)
  dat <- MASS::mvrnorm(n = n, mu = c(0, 0), Sigma = sigma)
  colnames(dat) <- c("x", "y")
  cls <- paste0("class_", 1:2)
  as_tibble(dat) |>
    mutate(
      linear_pred = !!eqn,
      linear_pred = linear_pred + rnorm(n, sd = error)
    )
}
```

### 

`linkinv()` returns the inverse link function of a ``parameters'' object. If the model's developer did not specify one (but did specify a link function) this function returns a numerical approximation of the link function.

### Exercise 9

Copy the previous code and add the parameter `prob`, setting it equal to `binomial()$linkinv(linear_pred)`.

```{r equicoval-results-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r equicoval-results-9-hint-1, eval = FALSE}
function (n, error = 0.1, eqn = quote(-1 - 2 * x - 0.2 * x^2 + 2 * y^2))  {
  ...
  as_tibble(dat) |>
    mutate(
      linear_pred = !!eqn,
      linear_pred = linear_pred + rnorm(n, sd = error),
      prob = ...()$linkinv(...)
    )
}
```

```{r include = FALSE}
function (n, error = 0.1, eqn = quote(-1 - 2 * x - 0.2 * x^2 + 2 * y^2))  {
  sigma <- matrix(c(1, 0.7, 0.7, 1), nrow = 2, ncol = 2)
  dat <- MASS::mvrnorm(n = n, mu = c(0, 0), Sigma = sigma)
  colnames(dat) <- c("x", "y")
  cls <- paste0("class_", 1:2)
  as_tibble(dat) |>
    mutate(
      linear_pred = !!eqn,
      linear_pred = linear_pred + rnorm(n, sd = error),
      prob = binomial()$linkinv(linear_pred)
    )
}
```

### 

**mvrnorm** parameters explained:
`Sigma`: This is a positive definite covariance matrix that defines the relationships and variabilities between the variables. It should have dimensions compatible with the length of mu (p x p, where p is the number of variables).

### Exercise 10

Copy the previous code and, on the next line, set `class` to an `ifelse()` statement. Set the first parameter in `ifelse()` to check `prob > runif(n)`. Add the parameter for if the check is true, `cls[1]`, and add for if the check is false, `cls[2]`.

```{r equicoval-results-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r equicoval-results-10-hint-1, eval = FALSE}
function (n, error = 0.1, eqn = quote(-1 - 2 * x - 0.2 * x^2 + 2 * y^2))  {
  ...
  as_tibble(dat) |>
    mutate(
      linear_pred = !!eqn,
      linear_pred = linear_pred + rnorm(n, sd = error),
      prob = binomial()$linkinv(linear_pred),
      class = ifelse(... > runif(n), cls[...], cls[...])
    )
}
```

```{r include = FALSE}
function (n, error = 0.1, eqn = quote(-1 - 2 * x - 0.2 * x^2 + 2 * y^2))  {
  sigma <- matrix(c(1, 0.7, 0.7, 1), nrow = 2, ncol = 2)
  dat <- MASS::mvrnorm(n = n, mu = c(0, 0), Sigma = sigma)
  colnames(dat) <- c("x", "y")
  cls <- paste0("class_", 1:2)
  as_tibble(dat) |>
    mutate(
      linear_pred = !!eqn,
      linear_pred = linear_pred + rnorm(n, sd = error),
      prob = binomial()$linkinv(linear_pred),
      class = ifelse(prob > runif(n), cls[1], cls[2])
    )
}
```

### 

**MASS** package provides a collection of functions for linear/non-linear regresson, cluster analysis, etc., and datasets that cover a wide range of statistical techniques.

### Exercise 11

Copy the previous code and add the final parameter to `mutate()`. Set `class` equal to `factor()`. Add the parameters `class` and `levels`, setting it equal to `cls`. Then, set the entire expression, from `as_tibble()`, to `dat` using `<-`.

```{r equicoval-results-11, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r equicoval-results-11-hint-1, eval = FALSE}
function (n, error = 0.1, eqn = quote(-1 - 2 * x - 0.2 * x^2 + 2 * y^2))  {
  ...
  dat <-
    as_tibble(dat) |>
    mutate(
      linear_pred = !!eqn,
      linear_pred = linear_pred + rnorm(n, sd = error),
      prob = binomial()$linkinv(linear_pred),
      class = ifelse(prob > runif(n), cls[1], cls[2]),
      class = factor(..., levels = ...)
    )
}
```

```{r include = FALSE}
function (n, error = 0.1, eqn = quote(-1 - 2 * x - 0.2 * x^2 + 2 * y^2)) {
  sigma <- matrix(c(1, 0.7, 0.7, 1), nrow = 2, ncol = 2)
  dat <- MASS::mvrnorm(n = n, mu = c(0, 0), Sigma = sigma)
  colnames(dat) <- c("x", "y")
  cls <- paste0("class_", 1:2)
  dat <-
    as_tibble(dat) |>
    mutate(
      linear_pred = !!eqn,
      linear_pred = linear_pred + rnorm(n, sd = error),
      prob = binomial()$linkinv(linear_pred),
      class = ifelse(prob > runif(n), cls[1], cls[2]),
      class = factor(class, levels = cls)
    )
}
```

### 

The `paste0()` function in R is used to concatenate (combine) multiple character strings into a single string without any separator. It is a convenient way to join strings together.

### Exercise 12

Copy the previous code and, outside `mutate()` but within the function, type `dplyr::select()`. Add the parameters `dat`, `x`, `y`, and `class`. Then, set the entire function to `simulate_two_classes` using `<-`.

```{r equicoval-results-12, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r equicoval-results-12-hint-1, eval = FALSE}
simulate_two_classes <-
  function (n, error = 0.1, eqn = quote(-1 - 2 * x - 0.2 * x^2 + 2 * y^2))  {
  ...
  dplyr::select(..., x, y, ...)
}
```

```{r include = FALSE}
simulate_two_classes <- 
  function (n, error = 0.1, eqn = quote(-1 - 2 * x - 0.2 * x^2 + 2 * y^2))  {
    sigma <- matrix(c(1, 0.7, 0.7, 1), nrow = 2, ncol = 2)
    dat <- MASS::mvrnorm(n = n, mu = c(0, 0), Sigma = sigma)
    colnames(dat) <- c("x", "y")
    cls <- paste0("class_", 1:2)
    dat <- 
      as_tibble(dat) |>
      mutate(
        linear_pred = !!eqn,
        linear_pred = linear_pred + rnorm(n, sd = error),
        prob = binomial()$linkinv(linear_pred),
        class = ifelse(prob > runif(n), cls[1], cls[2]),
        class = factor(class, levels = cls)
      )
    dplyr::select(dat, x, y, class)
  }
```

### 

`paste0()` code creates two strings: "class_1" and "class_2". The 1:2 generates a numeric vector containing the numbers 1 and 2. `paste0()` then concatenates each element of the numeric vector with the string `"class_"`, resulting in the vector of character strings shown in the output.

### Exercise 13

Outside of the function, type `simulate_two_classes(200)` and set it to `training_set`. Then on the next line, type `simulate_two_classes(50)` and set it to `testing_set`.

```{r equicoval-results-13, exercise = TRUE}

```

```{r equicoval-results-13-hint-1, eval = FALSE}
training_set <- simulate_two_classes(...)
testing_set <- simulate_two_classes(...)
```

```{r include = FALSE}
training_set <- simulate_two_classes(200)
testing_set <- simulate_two_classes(50)
```

### 

`logistic_reg()` defines a generalized linear model for binary outcomes. A linear combination of the predictors is used to model the log odds of an event. This function can fit classification models. 

### Exercise 14

Pipe `logistic_reg()` to `set_engine()`. Add the parameter `"stan"`.

```{r equicoval-results-14, exercise = TRUE}

```

```{r equicoval-results-14-hint, eval = FALSE}
logistic_reg() |>
  set_engine("...")
```

```{r, include = FALSE}
logistic_reg() |>
  set_engine("stan")
```

###

Examples of different engines that can be used with `set_engine()`: `glm`, `ranger`, `xgboost`, `keras`, `spark`, `h20`, etc.

### Exercise 15

Copy the previous code and pipe it to `fit()`. Add the parameters `class ~ . + I(x^2)+ I(y^2)` and `data`, setting it equal to `training_set`. Then, set the entire expression to `two_class_mod` using `<-`.

```{r equicoval-results-15, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r equicoval-results-15-hint, eval = FALSE}
two_class_mod <-
  ... |>
  fit(..., data = ...)
```

```{r, include = FALSE}
two_class_mod <-
  logistic_reg() |>
  set_engine("stan") |>
  fit(class ~ . + I(x^2)+ I(y^2), data = training_set)
```

###

`quote()` function is used to create a "quotation" of an expression without evaluating it immediately. Useful when working with non-standard evaluation (NSE) or when you want to capture an expression to manipulate it programmatically. 

### Exercise 16

Print `two_class_mod` using `print()`. Add the parameters `two_class_mod` and `digits = 3`.

```{r equicoval-results-16, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r equicoval-results-16-hint, eval = FALSE}
print(..., digits = 3)
```

```{r, include = FALSE}
print(two_class_mod, digits = 3)
```

###

We estimated a logistic regression model using Bayesian methods (using the default Gaussian prior distributions for the parameters).

### Exercise 17

Type in `augment()` and add the parameters `two_class_mod` and `testing_set`. Then, set the entire expression to `test_pred`.

```{r equicoval-results-17, exercise = TRUE}

```

```{r equicoval-results-17-hint, eval = FALSE}
test_pred <- augment(..., testing_set)
```

```{r, include = FALSE}
test_pred <- augment(two_class_mod, testing_set)
```

###

The `augment()` function is commonly associated with the broom package. It is used to augment statistical model objects with additional information or predictions, making them more suitable for further analysis, visualization, or reporting. 

### Exercise 18

Type `test_pred`. Pipe it to `head()` and hit "Run Code".

```{r equicoval-results-18, exercise = TRUE}

```

```{r equicoval-results-18-hint, eval = FALSE}
test_pred |>
  ...()
```

```{r, include = FALSE}
test_pred |>
  head()
```

###

With **tidymodels**, the **probably** package contains functions for equivocal zones. For cases with two classes, the `make_two_class_pred()` function creates a factor-like column that has the predicted classes with an equivocal zone.

### Exercise 19

Load the library `probably` using `library()`.

```{r equicoval-results-19, exercise = TRUE}

```

```{r equicoval-results-19-hint, eval = FALSE}
library(...)
```

```{r, include = FALSE}
#library(probably)
```

###

**probably**: Models can be improved by post-processing class probabilities, by: recalibration, conversion to hard probabilities, assessment of equivocal zones, and other activities. 'probably' contains tools for conducting these operations as well as calibration tools and conformal inference techniques for regression models.

### Exercise 20

Type `levels()` and the parameter `training_set$class`. Set the entire expression to `lvls` using `<-`.

```{r equicoval-results-20, exercise = TRUE}

```

```{r equicoval-results-20-hint, eval = FALSE}
lvls <- levels(...$class)
```

```{r, include = FALSE}
lvls <- levels(training_set$class)
```

###

One simple method for disqualifying results is to call them “equivocal” if the values are within some range around 50% (or the appropriate probability cutoff for a certain situation).

### Exercise 21

Type `test_pred` and pipe it to `mutate()`. Add the parameter `.pred_with_eqz`, setting it equal to `make_two_class_pred(.pred_class_1, lvls, buffer = 0.15)`. Set the entire expression to `test_pred1`.

```{r equicoval-results-21, exercise = TRUE}

```

```{r equicoval-results-21-hint, eval = FALSE}
test_pred1 <-
  test_pred |>
  mutate(...)
```

```{r, include = FALSE}
test_pred1 <-
  test_pred |>
  mutate(.pred_with_eqz = make_two_class_pred(.pred_class_1, lvls, buffer = 0.15))
```

###

`make_two_class_pred()` can be used to convert class probability estimates to `class_pred` objects with an optional equivocal zone.

### Exercise 22

Type `test_pred1` and pipe it to `count()`. Add the parameter `.pred_with_eqz`.

```{r equicoval-results-22, exercise = TRUE}

```

```{r equicoval-results-22-hint, eval = FALSE}
test_pred1 |>
  count(...)
```

```{r, include = FALSE}
test_pred1 |>
  count(.pred_with_eqz)
```

###

Since the factor levels are the same as the original data, confusion matrices and other statistics can be computed without error. When using standard functions from the **yardstick** package, the equivocal results are converted to `NA` and are not used in the calculations that use the hard class predictions.

### Exercise 23

Type `test_pred1` and pipe it to `conf_mat()`. Add the parameter `class` and `.pred_with_eqz`, giving the outcome of only reportable results.

```{r equicoval-results-23, exercise = TRUE}

```

```{r equicoval-results-23-hint, eval = FALSE}
test_pred |>
  conf_mat(class, ...)
```

```{r, include = FALSE}
test_pred |>
  conf_mat(class, .pred_with_eqz)
```

###



## Summary
### 

<!-- Two to four sentences which bring the lessons of the tutorial together for the student. What do they know now that they did not know before? How does this tutorial connect to other tutorials? OK if this is very similar to the Introduction. You made a promise as to what they would learn. You (we hope!) kept that promise.-->

```{r download-answers, child = system.file("child_documents/download_answers.Rmd", package = "tutorial.helpers")}
```
